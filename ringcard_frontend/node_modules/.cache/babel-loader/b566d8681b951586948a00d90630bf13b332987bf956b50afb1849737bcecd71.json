{"ast":null,"code":"const objectHash = require('object-hash');\nconst LRU = require('lru-cache');\nconst {\n  RPError\n} = require('../errors');\nconst {\n  assertIssuerConfiguration\n} = require('./assert');\nconst KeyStore = require('./keystore');\nconst {\n  keystores\n} = require('./weak_cache');\nconst processResponse = require('./process_response');\nconst request = require('./request');\nconst inFlight = new WeakMap();\nconst caches = new WeakMap();\nconst lrus = ctx => {\n  if (!caches.has(ctx)) {\n    caches.set(ctx, new LRU({\n      max: 100\n    }));\n  }\n  return caches.get(ctx);\n};\nasync function getKeyStore() {\n  let reload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  assertIssuerConfiguration(this, 'jwks_uri');\n  const keystore = keystores.get(this);\n  const cache = lrus(this);\n  if (reload || !keystore) {\n    if (inFlight.has(this)) {\n      return inFlight.get(this);\n    }\n    cache.reset();\n    inFlight.set(this, (async () => {\n      const response = await request.call(this, {\n        method: 'GET',\n        responseType: 'json',\n        url: this.jwks_uri,\n        headers: {\n          Accept: 'application/json, application/jwk-set+json'\n        }\n      }).finally(() => {\n        inFlight.delete(this);\n      });\n      const jwks = processResponse(response);\n      const joseKeyStore = KeyStore.fromJWKS(jwks, {\n        onlyPublic: true\n      });\n      cache.set('throttle', true, 60 * 1000);\n      keystores.set(this, joseKeyStore);\n      return joseKeyStore;\n    })());\n    return inFlight.get(this);\n  }\n  return keystore;\n}\nasync function queryKeyStore(_ref) {\n  let {\n    kid,\n    kty,\n    alg,\n    use\n  } = _ref;\n  let {\n    allowMulti = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const cache = lrus(this);\n  const def = {\n    kid,\n    kty,\n    alg,\n    use\n  };\n  const defHash = objectHash(def, {\n    algorithm: 'sha256',\n    ignoreUnknown: true,\n    unorderedArrays: true,\n    unorderedSets: true\n  });\n\n  // refresh keystore on every unknown key but also only upto once every minute\n  const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n  const keystore = await getKeyStore.call(this, !freshJwksUri);\n  const keys = keystore.all(def);\n  delete def.use;\n  if (keys.length === 0) {\n    throw new RPError({\n      printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n      jwks: keystore\n    });\n  }\n  if (!allowMulti && keys.length > 1 && !kid) {\n    throw new RPError({\n      printf: [\"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\", def],\n      jwks: keystore\n    });\n  }\n  cache.set(defHash, true);\n  return keys;\n}\nmodule.exports.queryKeyStore = queryKeyStore;\nmodule.exports.keystore = getKeyStore;","map":{"version":3,"names":["objectHash","require","LRU","RPError","assertIssuerConfiguration","KeyStore","keystores","processResponse","request","inFlight","WeakMap","caches","lrus","ctx","has","set","max","get","getKeyStore","reload","keystore","cache","reset","response","call","method","responseType","url","jwks_uri","headers","Accept","finally","delete","jwks","joseKeyStore","fromJWKS","onlyPublic","queryKeyStore","kid","kty","alg","use","allowMulti","def","defHash","algorithm","ignoreUnknown","unorderedArrays","unorderedSets","freshJwksUri","keys","all","length","printf","module","exports"],"sources":["C:/Users/yuleg/Dev/Ringca/ORIN33/ringcard/ringcard_frontend/node_modules/openid-client/lib/helpers/issuer.js"],"sourcesContent":["const objectHash = require('object-hash');\nconst LRU = require('lru-cache');\n\nconst { RPError } = require('../errors');\n\nconst { assertIssuerConfiguration } = require('./assert');\nconst KeyStore = require('./keystore');\nconst { keystores } = require('./weak_cache');\nconst processResponse = require('./process_response');\nconst request = require('./request');\n\nconst inFlight = new WeakMap();\nconst caches = new WeakMap();\nconst lrus = (ctx) => {\n  if (!caches.has(ctx)) {\n    caches.set(ctx, new LRU({ max: 100 }));\n  }\n  return caches.get(ctx);\n};\n\nasync function getKeyStore(reload = false) {\n  assertIssuerConfiguration(this, 'jwks_uri');\n\n  const keystore = keystores.get(this);\n  const cache = lrus(this);\n\n  if (reload || !keystore) {\n    if (inFlight.has(this)) {\n      return inFlight.get(this);\n    }\n    cache.reset();\n    inFlight.set(\n      this,\n      (async () => {\n        const response = await request\n          .call(this, {\n            method: 'GET',\n            responseType: 'json',\n            url: this.jwks_uri,\n            headers: {\n              Accept: 'application/json, application/jwk-set+json',\n            },\n          })\n          .finally(() => {\n            inFlight.delete(this);\n          });\n        const jwks = processResponse(response);\n\n        const joseKeyStore = KeyStore.fromJWKS(jwks, { onlyPublic: true });\n        cache.set('throttle', true, 60 * 1000);\n        keystores.set(this, joseKeyStore);\n\n        return joseKeyStore;\n      })(),\n    );\n\n    return inFlight.get(this);\n  }\n\n  return keystore;\n}\n\nasync function queryKeyStore({ kid, kty, alg, use }, { allowMulti = false } = {}) {\n  const cache = lrus(this);\n\n  const def = {\n    kid,\n    kty,\n    alg,\n    use,\n  };\n\n  const defHash = objectHash(def, {\n    algorithm: 'sha256',\n    ignoreUnknown: true,\n    unorderedArrays: true,\n    unorderedSets: true,\n  });\n\n  // refresh keystore on every unknown key but also only upto once every minute\n  const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n\n  const keystore = await getKeyStore.call(this, !freshJwksUri);\n  const keys = keystore.all(def);\n\n  delete def.use;\n  if (keys.length === 0) {\n    throw new RPError({\n      printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n      jwks: keystore,\n    });\n  }\n\n  if (!allowMulti && keys.length > 1 && !kid) {\n    throw new RPError({\n      printf: [\n        \"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\",\n        def,\n      ],\n      jwks: keystore,\n    });\n  }\n\n  cache.set(defHash, true);\n\n  return keys;\n}\n\nmodule.exports.queryKeyStore = queryKeyStore;\nmodule.exports.keystore = getKeyStore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}