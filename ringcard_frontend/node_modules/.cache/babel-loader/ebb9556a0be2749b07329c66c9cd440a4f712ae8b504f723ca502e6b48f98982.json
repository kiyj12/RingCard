{"ast":null,"code":"import _regeneratorRuntime from\"C:/Users/yuleg/Dev/Ringca/ORIN33/ringcard/ringcard_frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _asyncToGenerator from\"C:/Users/yuleg/Dev/Ringca/ORIN33/ringcard/ringcard_frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import React,{useEffect}from\"react\";import{useNavigate}from\"react-router-dom\";import{TwitterApi}from'twitter-api-v2';import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var Oauth=function Oauth(){var CONSUMER_KEY=process.env.REACT_APP_CONSUMER_KEY;var CONSUMER_SECRET=process.env.REACT_APP_CONSUMER_SECRET;var CLIENT_ID=process.env.REACT_APP_CLIENT_ID;var CLIENT_SECRET=process.env.REACT_APP_CLIENT_SECRET;var ACCESS_TOKEN=process.env.REACT_APP_ACCESS_TOKEN;var ACCESS_TOKEN_SECRET=process.env.REACT_APP_ACCESS_TOKEN_SECRET;var CALLBACK_URL=process.env.REACT_APP_CALLBACK_URL;var BEARER_TOKEN=process.env.REACT_APP_BEARER_TOKEN;var navigate=useNavigate();// var global = global || window;\nglobal.Buffer=global.Buffer||require(\"buffer\").Buffer;// 일단 oauth1.0a로 해보자.\n// const client = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\n// useEffect(() => {\n//   const oauthTest = async () => {\n//     if(CONSUMER_KEY && CONSUMER_SECRET){\n//     const clientA = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\n//     console.log(clientA);\n//     const authLink = await clientA.generateAuthLink(CALLBACK_URL);\n//     console.log(authLink.url);\n//   }\n// };\n// \toauthTest();\n// }, []);\n// 애플리케이션 전용 인증 흐름\n//   useEffect(() => {\n//     const oauthTest = async () => {\n//       if(CONSUMER_KEY && CONSUMER_SECRET && BEARER_TOKEN){\n//       const client = new TwitterApi(BEARER_TOKEN);\n// console.log(client);\n//       const consumerClient = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\n//       // Obtain app-only client\n//       const clientA = await consumerClient.appLogin();\n//       console.log(clientA);\n//       // const authLink = await clientA.generateAuthLink(CALLBACK_URL);\n//       // console.log(authLink.url);\n//     }\n//   };\n// \t\toauthTest();\n// \t}, []);\n// OAuth2 사용자 전체 인증 흐름\nuseEffect(function(){var oauthTest=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(){return _regeneratorRuntime().wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:case\"end\":return _context.stop();}}},_callee);}));return function oauthTest(){return _ref.apply(this,arguments);};}();oauthTest();},[]);// OAuth 1.0a (User context)\nvar userClient=new TwitterApi({// appKey: 'consumerAppKey',\nappKey:'S0FVySANFNnlISMw5D1vSE8P0',// appSecret: 'consumerAppSecret',\nappSecret:'KCu23eNrVftMqQeefWJTIei5Klju341e78BypImTVfw338Mm0X',// Following access tokens are not required if you are\n// at part 1 of user-auth process (ask for a request token)\n// or if you want a app-only client (see below)\n// accessToken: 'accessOAuthToken',\naccessToken:'1516353113430851586-Qhjz3YpRRL1yFqSa5PYcyjf5gmJhU1',// accessSecret: 'accessOAuthSecret',\naccessSecret:'accdPvdajDmTYtMybqbj9mOMnTIvbE9SnOuJY8h9uRQjRxlnessOAuthSecret'});function Oauth1a(){return _Oauth1a.apply(this,arguments);}function _Oauth1a(){_Oauth1a=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(){var clientA,authLink,a,oauth_token,oauth_token_secret;return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!(CONSUMER_KEY&&CONSUMER_SECRET)){_context2.next=11;break;}clientA=new TwitterApi({appKey:CONSUMER_KEY,appSecret:CONSUMER_SECRET});console.log(clientA);_context2.next=5;return clientA.generateAuthLink(CALLBACK_URL,{linkMode:'authorize'});case 5:authLink=_context2.sent;// Obtain the persistent tokens\n// Create a client from temporary tokens\n//   const client = new TwitterApi({\n//   appKey: CONSUMER_KEY,\n//   appSecret: CONSUMER_SECRET,\n//   accessToken: oauth_token, // oauth token from previous step (link generation)\n//   accessSecret: oauth_token_secret, // oauth token secret from previous step (link generation)\n// });\n// By default, oauth/authenticate are used for auth links, you can change with linkMode\n// property in second parameter to 'authorize' to use oauth/authorize\n// if(client){\n//   const authLink = await client.generateAuthLink(CALLBACK_URL, { linkMode: 'authorize' });\n// }\n// Use URL generated\na=authLink.url;oauth_token=authLink.oauth_token;oauth_token_secret=authLink.oauth_token_secret;console.log(oauth_token);console.log(oauth_token_secret);// console.log(a);\n// Give the PIN to client.login()\n// const { client: loggedClient, accessToken, accessSecret } = await client.login(GIVEN_USER_PIN);\n// loggedClient is an authenticated client in behalf of some user\n// Store accessToken & accessSecret somewhere\ncase 11:case\"end\":return _context2.stop();}}},_callee2);}));return _Oauth1a.apply(this,arguments);}function ButtonToUserInfoEdit(){function handleClick(e){Oauth1a();}return/*#__PURE__*/_jsx(\"button\",{className:\"user-btn userInfo-btn\",onClick:handleClick,children:/*#__PURE__*/_jsx(\"div\",{className:\"user-btn-text\",children:\"\\uD504\\uB85C\\uD544 \\uBCC0\\uACBD\\uD558\\uAE30\"})});}//   // OAuth2 (app-only or user context)\n//   // Create a client with an already known bearer token\n//   const appOnlyClient = new TwitterApi('bearerToken');\n//   // OR - you can also create a app-only client from your consumer keys -\n//   const appOnlyClientFromConsumer = await userClient.appLogin();\n//   // Oauth2\n// \t// if로 undefined 처리)\n// \tif (CLIENT_ID && CLIENT_SECRET && CALLBACK_URL){\n// \t\tconst client = new TwitterApi({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET });\n// \t\t// Don't forget to specify 'offline.access' in scope list if you want to refresh your token later\n// \t\tconst { url, codeVerifier, state } = client.generateOAuth2AuthLink(CALLBACK_URL, { scope: ['tweet.read', 'users.read', 'offline.access'] });\n// \t\t// Redirect your user to {url}, store {state} and {codeVerifier} into a DB/Redis/memory after user redirection\n//     // const a = url;\n//     // console.log(a);\n// \t\t// client.generateAuthLink();\n// \t\tnavigate(url);\n//     // console.log(url);\n// \t\t// console.log(url);\n//   app.get('/callback', (req:any, res:any) => {\n//   // Extract state and code from query string\n//   const { state, code } = req.query;\n//   // Get the saved codeVerifier from session\n//   const { codeVerifier, state: sessionState } = req.session;\n//   if (!codeVerifier || !state || !sessionState || !code) {\n//     return res.status(400).send('You denied the app or your session expired!');\n//   }\n//   if (state !== sessionState) {\n//     return res.status(400).send('Stored tokens didnt match!');\n//   }\n//   // Obtain access token\n//   const client = new TwitterApi({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET });\n//   client.loginWithOAuth2({ code, codeVerifier, redirectUri: CALLBACK_URL })\n//     .then(async ({ client: loggedClient, accessToken, refreshToken, expiresIn }) => {\n//       // {loggedClient} is an authenticated client in behalf of some user\n//       // Store {accessToken} somewhere, it will be valid until {expiresIn} is hit.\n//       // If you want to refresh your token later, store {refreshToken} (it is present if 'offline.access' has been given as scope)\n//       // Example request\n//       const { data: userObject } = await loggedClient.v2.me();\n//     })\n//     .catch(() => res.status(403).send('Invalid verifier or access tokens!'));\n// });\n// }\nreturn/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"div\",{children:/*#__PURE__*/_jsx(ButtonToUserInfoEdit,{})}),/*#__PURE__*/_jsx(\"div\",{children:/*#__PURE__*/_jsx(\"a\",{href:\"https://twitter.com/i/oauth2/authorize?code_challenge=challenge&code_challenge_method=plain&response_type=code&client_id=OHZuVXNLOU9Yd2xEZTM1Q3pSTl86MTpjaQ&scope=tweet.read%20tweet.write%20offline.access%20users.read&state=gAPgtEQt6LqmziQPJ9sqy56-cxdSgV97xtbpyGMMYjY%3D&redirect_uri=http://localhost:8080/login/oauth2/code/twitter\",children:\"\\uD2B8\\uC704\\uD130 \\uB85C\\uADF8\\uC778\"})})]});};export default Oauth;","map":{"version":3,"names":["React","useEffect","useNavigate","TwitterApi","Oauth","CONSUMER_KEY","process","env","REACT_APP_CONSUMER_KEY","CONSUMER_SECRET","REACT_APP_CONSUMER_SECRET","CLIENT_ID","REACT_APP_CLIENT_ID","CLIENT_SECRET","REACT_APP_CLIENT_SECRET","ACCESS_TOKEN","REACT_APP_ACCESS_TOKEN","ACCESS_TOKEN_SECRET","REACT_APP_ACCESS_TOKEN_SECRET","CALLBACK_URL","REACT_APP_CALLBACK_URL","BEARER_TOKEN","REACT_APP_BEARER_TOKEN","navigate","global","Buffer","require","oauthTest","userClient","appKey","appSecret","accessToken","accessSecret","Oauth1a","clientA","console","log","generateAuthLink","linkMode","authLink","a","url","oauth_token","oauth_token_secret","ButtonToUserInfoEdit","handleClick","e"],"sources":["C:/Users/yuleg/Dev/Ringca/ORIN33/ringcard/ringcard_frontend/src/pages/login/Oauth.tsx"],"sourcesContent":["import React, { useEffect } from \"react\";\r\nimport { useNavigate } from \"react-router-dom\";\r\nimport { TwitterApi } from 'twitter-api-v2';\r\nimport { Buffer } from \"buffer\";\r\n\r\nconst Oauth= ()=>{\r\n\r\n  const CONSUMER_KEY=process.env.REACT_APP_CONSUMER_KEY;\r\n  const CONSUMER_SECRET=process.env.REACT_APP_CONSUMER_SECRET;\r\n  const CLIENT_ID=process.env.REACT_APP_CLIENT_ID;\r\n\tconst CLIENT_SECRET=process.env.REACT_APP_CLIENT_SECRET;\r\n\tconst ACCESS_TOKEN=process.env.REACT_APP_ACCESS_TOKEN;\r\n\tconst ACCESS_TOKEN_SECRET=process.env.REACT_APP_ACCESS_TOKEN_SECRET;\r\n\tconst CALLBACK_URL=process.env.REACT_APP_CALLBACK_URL;\r\n\tconst BEARER_TOKEN=process.env.REACT_APP_BEARER_TOKEN;\r\n\tconst navigate = useNavigate();\r\n\r\n  // var global = global || window;\r\n    global.Buffer = global.Buffer || require(\"buffer\").Buffer;  \r\n\r\n  // 일단 oauth1.0a로 해보자.\r\n  // const client = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\r\n\r\n  // useEffect(() => {\r\n  //   const oauthTest = async () => {\r\n  //     if(CONSUMER_KEY && CONSUMER_SECRET){\r\n  //     const clientA = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\r\n\r\n  //     console.log(clientA);\r\n\r\n  //     const authLink = await clientA.generateAuthLink(CALLBACK_URL);\r\n  //     console.log(authLink.url);\r\n  //   }\r\n  // };\r\n\t// \toauthTest();\r\n\t// }, []);\r\n\r\n  // 애플리케이션 전용 인증 흐름\r\n//   useEffect(() => {\r\n//     const oauthTest = async () => {\r\n//       if(CONSUMER_KEY && CONSUMER_SECRET && BEARER_TOKEN){\r\n//       const client = new TwitterApi(BEARER_TOKEN);\r\n// console.log(client);\r\n//       const consumerClient = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\r\n//       // Obtain app-only client\r\n//       const clientA = await consumerClient.appLogin();\r\n\r\n//       console.log(clientA);\r\n\r\n//       // const authLink = await clientA.generateAuthLink(CALLBACK_URL);\r\n//       // console.log(authLink.url);\r\n//     }\r\n//   };\r\n// \t\toauthTest();\r\n// \t}, []);\r\n\r\n  // OAuth2 사용자 전체 인증 흐름\r\n\r\n  useEffect(() => {\r\n    const oauthTest = async () => {\r\n      // if(CLIENT_ID&&CLIENT_SECRET&&CALLBACK_URL){\r\n      //   const client = new TwitterApi({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET });\r\n      // const { url, codeVerifier, state } = client.generateOAuth2AuthLink(CALLBACK_URL, { scope: ['tweet.read', 'users.read', 'offline.access'] });\r\n      // }\r\n      // if(ACCESS_TOKEN){\r\n      // const client = new TwitterApi(ACCESS_TOKEN);\r\n      // }\r\n    }\r\n\t\toauthTest();\r\n\t}, []);\r\n\r\n  // OAuth 1.0a (User context)\r\n  const userClient = new TwitterApi({\r\n    // appKey: 'consumerAppKey',\r\n    appKey: 'S0FVySANFNnlISMw5D1vSE8P0',\r\n    // appSecret: 'consumerAppSecret',\r\n    appSecret: 'KCu23eNrVftMqQeefWJTIei5Klju341e78BypImTVfw338Mm0X',\r\n    // Following access tokens are not required if you are\r\n    // at part 1 of user-auth process (ask for a request token)\r\n    // or if you want a app-only client (see below)\r\n    // accessToken: 'accessOAuthToken',\r\n    accessToken: '1516353113430851586-Qhjz3YpRRL1yFqSa5PYcyjf5gmJhU1',\r\n    // accessSecret: 'accessOAuthSecret',\r\n    accessSecret: 'accdPvdajDmTYtMybqbj9mOMnTIvbE9SnOuJY8h9uRQjRxlnessOAuthSecret',\r\n  });\r\n  async function Oauth1a(){\r\n    if(CONSUMER_KEY && CONSUMER_SECRET){\r\n      const clientA = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\r\n\r\n      console.log(clientA);\r\n\r\n      const authLink = await clientA.generateAuthLink(CALLBACK_URL, { linkMode: 'authorize' });\r\n\r\n\r\n       // Obtain the persistent tokens\r\n  // Create a client from temporary tokens\r\n\r\n\r\n\r\n  //   const client = new TwitterApi({\r\n  //   appKey: CONSUMER_KEY,\r\n  //   appSecret: CONSUMER_SECRET,\r\n  //   accessToken: oauth_token, // oauth token from previous step (link generation)\r\n  //   accessSecret: oauth_token_secret, // oauth token secret from previous step (link generation)\r\n  // });\r\n\r\n    // By default, oauth/authenticate are used for auth links, you can change with linkMode\r\n    // property in second parameter to 'authorize' to use oauth/authorize\r\n    // if(client){\r\n    //   const authLink = await client.generateAuthLink(CALLBACK_URL, { linkMode: 'authorize' });\r\n    // }\r\n    \r\n\r\n    // Use URL generated\r\n    const a = authLink.url;\r\n    const oauth_token = authLink.oauth_token;\r\n    const oauth_token_secret = authLink.oauth_token_secret;\r\n    console.log(oauth_token);\r\n    console.log(oauth_token_secret);\r\n    // console.log(a);\r\n\r\n   \r\n\r\n// Give the PIN to client.login()\r\n// const { client: loggedClient, accessToken, accessSecret } = await client.login(GIVEN_USER_PIN);\r\n// loggedClient is an authenticated client in behalf of some user\r\n// Store accessToken & accessSecret somewhere\r\n    }\r\n  }\r\n\r\n  function ButtonToUserInfoEdit() {\r\n\t\tfunction handleClick(e: any) {\r\n      Oauth1a();\r\n    }\r\n\t\treturn (\r\n\t\t\t<button className=\"user-btn userInfo-btn\" onClick={handleClick}>\r\n\t\t\t\t<div className=\"user-btn-text\">프로필 변경하기</div>\r\n\t\t\t</button>\r\n\t\t);\r\n\t}\r\n\r\n\r\n\r\n//   // OAuth2 (app-only or user context)\r\n//   // Create a client with an already known bearer token\r\n//   const appOnlyClient = new TwitterApi('bearerToken');\r\n//   // OR - you can also create a app-only client from your consumer keys -\r\n//   const appOnlyClientFromConsumer = await userClient.appLogin();\r\n\r\n//   // Oauth2\r\n// \t// if로 undefined 처리)\r\n// \tif (CLIENT_ID && CLIENT_SECRET && CALLBACK_URL){\r\n// \t\tconst client = new TwitterApi({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET });\r\n\r\n// \t\t// Don't forget to specify 'offline.access' in scope list if you want to refresh your token later\r\n// \t\tconst { url, codeVerifier, state } = client.generateOAuth2AuthLink(CALLBACK_URL, { scope: ['tweet.read', 'users.read', 'offline.access'] });\r\n\r\n// \t\t// Redirect your user to {url}, store {state} and {codeVerifier} into a DB/Redis/memory after user redirection\r\n    \r\n//     // const a = url;\r\n//     // console.log(a);\r\n// \t\t// client.generateAuthLink();\r\n// \t\tnavigate(url);\r\n//     // console.log(url);\r\n// \t\t// console.log(url);\r\n\r\n//   app.get('/callback', (req:any, res:any) => {\r\n//   // Extract state and code from query string\r\n//   const { state, code } = req.query;\r\n//   // Get the saved codeVerifier from session\r\n//   const { codeVerifier, state: sessionState } = req.session;\r\n\r\n//   if (!codeVerifier || !state || !sessionState || !code) {\r\n//     return res.status(400).send('You denied the app or your session expired!');\r\n//   }\r\n//   if (state !== sessionState) {\r\n//     return res.status(400).send('Stored tokens didnt match!');\r\n//   }\r\n\r\n//   // Obtain access token\r\n//   const client = new TwitterApi({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET });\r\n\r\n//   client.loginWithOAuth2({ code, codeVerifier, redirectUri: CALLBACK_URL })\r\n//     .then(async ({ client: loggedClient, accessToken, refreshToken, expiresIn }) => {\r\n//       // {loggedClient} is an authenticated client in behalf of some user\r\n//       // Store {accessToken} somewhere, it will be valid until {expiresIn} is hit.\r\n//       // If you want to refresh your token later, store {refreshToken} (it is present if 'offline.access' has been given as scope)\r\n\r\n//       // Example request\r\n//       const { data: userObject } = await loggedClient.v2.me();\r\n//     })\r\n//     .catch(() => res.status(403).send('Invalid verifier or access tokens!'));\r\n// });\r\n\t// }\r\n\r\n  return(\r\n    <div>\r\n  <div><ButtonToUserInfoEdit /></div>\r\n  <div><a href=\"https://twitter.com/i/oauth2/authorize?code_challenge=challenge&code_challenge_method=plain&response_type=code&client_id=OHZuVXNLOU9Yd2xEZTM1Q3pSTl86MTpjaQ&scope=tweet.read%20tweet.write%20offline.access%20users.read&state=gAPgtEQt6LqmziQPJ9sqy56-cxdSgV97xtbpyGMMYjY%3D&redirect_uri=http://localhost:8080/login/oauth2/code/twitter\">트위터 로그인</a></div></div>);\r\n\r\n}\r\n\r\nexport default Oauth;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}