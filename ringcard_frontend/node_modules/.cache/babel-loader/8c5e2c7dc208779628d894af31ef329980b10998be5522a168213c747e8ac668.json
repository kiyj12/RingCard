{"ast":null,"code":"'use strict';\n\n// glorious streaming json parser, built specifically for the twitter streaming api\n// assumptions:\n//   1) ninjas are mammals\n//   2) tweets come in chunks of text, surrounded by {}'s, separated by line breaks\n//   3) only one tweet per chunk\n//\n//   p = new parser.instance()\n//   p.addListener('object', function...)\n//   p.receive(data)\n//   p.receive(data)\n//   ...\nvar EventEmitter = require('events').EventEmitter;\nvar Parser = module.exports = function Parser() {\n  // Make sure we call our parents constructor\n  EventEmitter.call(this);\n  this.buffer = '';\n  return this;\n};\n\n// The parser emits events!\nParser.prototype = Object.create(EventEmitter.prototype);\nParser.END = '\\r\\n';\nParser.END_LENGTH = 2;\nParser.prototype.receive = function receive(buffer) {\n  this.buffer += buffer.toString('utf8');\n  var index, json;\n\n  // We have END?\n  while ((index = this.buffer.indexOf(Parser.END)) > -1) {\n    json = this.buffer.slice(0, index);\n    this.buffer = this.buffer.slice(index + Parser.END_LENGTH);\n    if (json.length > 0) {\n      try {\n        json = JSON.parse(json);\n        // Event message\n        if (json.event !== undefined) {\n          // First emit specific event\n          this.emit(json.event, json);\n          // Now emit catch-all event\n          this.emit('event', json);\n        }\n        // Delete message\n        else if (json.delete !== undefined) {\n          this.emit('delete', json);\n        }\n        // Friends message (beginning of stream)\n        else if (json.friends !== undefined || json.friends_str !== undefined) {\n          this.emit('friends', json);\n        }\n        // Any other message\n        else {\n          this.emit('data', json);\n        }\n      } catch (error) {\n        error.source = json;\n        this.emit('error', error);\n      }\n    } else {\n      // Keep Alive\n      this.emit('ping');\n    }\n  }\n};","map":{"version":3,"names":["EventEmitter","require","Parser","module","exports","call","buffer","prototype","Object","create","END","END_LENGTH","receive","toString","index","json","indexOf","slice","length","JSON","parse","event","undefined","emit","delete","friends","friends_str","error","source"],"sources":["C:/Users/yuleg/Dev/Ringca/ORIN33/ringcard/ringcard_frontend/node_modules/twitter/lib/parser.js"],"sourcesContent":["'use strict';\n\n// glorious streaming json parser, built specifically for the twitter streaming api\n// assumptions:\n//   1) ninjas are mammals\n//   2) tweets come in chunks of text, surrounded by {}'s, separated by line breaks\n//   3) only one tweet per chunk\n//\n//   p = new parser.instance()\n//   p.addListener('object', function...)\n//   p.receive(data)\n//   p.receive(data)\n//   ...\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Parser = module.exports = function Parser() {\n  // Make sure we call our parents constructor\n  EventEmitter.call(this);\n  this.buffer = '';\n  return this;\n};\n\n// The parser emits events!\nParser.prototype = Object.create(EventEmitter.prototype);\n\nParser.END        = '\\r\\n';\nParser.END_LENGTH = 2;\n\nParser.prototype.receive = function receive(buffer) {\n  this.buffer += buffer.toString('utf8');\n  var index, json;\n\n  // We have END?\n  while ((index = this.buffer.indexOf(Parser.END)) > -1) {\n    json = this.buffer.slice(0, index);\n    this.buffer = this.buffer.slice(index + Parser.END_LENGTH);\n    if (json.length > 0) {\n      try {\n        json = JSON.parse(json);\n        // Event message\n        if (json.event !== undefined) {\n          // First emit specific event\n          this.emit(json.event, json);\n          // Now emit catch-all event\n          this.emit('event', json);\n        }\n        // Delete message\n        else if (json.delete !== undefined) {\n          this.emit('delete', json);\n        }\n        // Friends message (beginning of stream)\n        else if (json.friends !== undefined || json.friends_str !== undefined) {\n          this.emit('friends', json);\n        }\n        // Any other message\n        else {\n          this.emit('data', json);\n        }\n      }\n      catch (error) {\n        error.source = json;\n        this.emit('error', error);\n      }\n    }\n    else {\n      // Keep Alive\n      this.emit('ping');\n    }\n  }\n};\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,QAAQ,CAAC,CAACD,YAAY;AAEjD,IAAIE,MAAM,GAAGC,MAAM,CAACC,OAAO,GAAG,SAASF,MAAM,GAAG;EAC9C;EACAF,YAAY,CAACK,IAAI,CAAC,IAAI,CAAC;EACvB,IAAI,CAACC,MAAM,GAAG,EAAE;EAChB,OAAO,IAAI;AACb,CAAC;;AAED;AACAJ,MAAM,CAACK,SAAS,GAAGC,MAAM,CAACC,MAAM,CAACT,YAAY,CAACO,SAAS,CAAC;AAExDL,MAAM,CAACQ,GAAG,GAAU,MAAM;AAC1BR,MAAM,CAACS,UAAU,GAAG,CAAC;AAErBT,MAAM,CAACK,SAAS,CAACK,OAAO,GAAG,SAASA,OAAO,CAACN,MAAM,EAAE;EAClD,IAAI,CAACA,MAAM,IAAIA,MAAM,CAACO,QAAQ,CAAC,MAAM,CAAC;EACtC,IAAIC,KAAK,EAAEC,IAAI;;EAEf;EACA,OAAO,CAACD,KAAK,GAAG,IAAI,CAACR,MAAM,CAACU,OAAO,CAACd,MAAM,CAACQ,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;IACrDK,IAAI,GAAG,IAAI,CAACT,MAAM,CAACW,KAAK,CAAC,CAAC,EAAEH,KAAK,CAAC;IAClC,IAAI,CAACR,MAAM,GAAG,IAAI,CAACA,MAAM,CAACW,KAAK,CAACH,KAAK,GAAGZ,MAAM,CAACS,UAAU,CAAC;IAC1D,IAAII,IAAI,CAACG,MAAM,GAAG,CAAC,EAAE;MACnB,IAAI;QACFH,IAAI,GAAGI,IAAI,CAACC,KAAK,CAACL,IAAI,CAAC;QACvB;QACA,IAAIA,IAAI,CAACM,KAAK,KAAKC,SAAS,EAAE;UAC5B;UACA,IAAI,CAACC,IAAI,CAACR,IAAI,CAACM,KAAK,EAAEN,IAAI,CAAC;UAC3B;UACA,IAAI,CAACQ,IAAI,CAAC,OAAO,EAAER,IAAI,CAAC;QAC1B;QACA;QAAA,KACK,IAAIA,IAAI,CAACS,MAAM,KAAKF,SAAS,EAAE;UAClC,IAAI,CAACC,IAAI,CAAC,QAAQ,EAAER,IAAI,CAAC;QAC3B;QACA;QAAA,KACK,IAAIA,IAAI,CAACU,OAAO,KAAKH,SAAS,IAAIP,IAAI,CAACW,WAAW,KAAKJ,SAAS,EAAE;UACrE,IAAI,CAACC,IAAI,CAAC,SAAS,EAAER,IAAI,CAAC;QAC5B;QACA;QAAA,KACK;UACH,IAAI,CAACQ,IAAI,CAAC,MAAM,EAAER,IAAI,CAAC;QACzB;MACF,CAAC,CACD,OAAOY,KAAK,EAAE;QACZA,KAAK,CAACC,MAAM,GAAGb,IAAI;QACnB,IAAI,CAACQ,IAAI,CAAC,OAAO,EAAEI,KAAK,CAAC;MAC3B;IACF,CAAC,MACI;MACH;MACA,IAAI,CAACJ,IAAI,CAAC,MAAM,CAAC;IACnB;EACF;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}