{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TweetStreamEventCombiner = void 0;\nconst events_1 = require(\"events\");\nconst types_1 = require(\"../types\");\nclass TweetStreamEventCombiner extends events_1.EventEmitter {\n  constructor(stream) {\n    super();\n    this.stream = stream;\n    this.stack = [];\n    this.onStreamData = this.onStreamData.bind(this);\n    this.onStreamError = this.onStreamError.bind(this);\n    this.onceNewEvent = this.once.bind(this, 'event');\n    // Init events from stream\n    stream.on(types_1.ETwitterStreamEvent.Data, this.onStreamData);\n    // Ignore reconnect errors: Don't close event combiner until connection error/closed\n    stream.on(types_1.ETwitterStreamEvent.ConnectionError, this.onStreamError);\n    stream.on(types_1.ETwitterStreamEvent.TweetParseError, this.onStreamError);\n    stream.on(types_1.ETwitterStreamEvent.ConnectionClosed, this.onStreamError);\n  }\n  /** Returns a new `Promise` that will `resolve` on next event (`data` or any sort of error). */\n  nextEvent() {\n    return new Promise(this.onceNewEvent);\n  }\n  /** Returns `true` if there's something in the stack. */\n  hasStack() {\n    return this.stack.length > 0;\n  }\n  /** Returns stacked data events, and clean the stack. */\n  popStack() {\n    const stack = this.stack;\n    this.stack = [];\n    return stack;\n  }\n  /** Cleanup all the listeners attached on stream. */\n  destroy() {\n    this.removeAllListeners();\n    this.stream.off(types_1.ETwitterStreamEvent.Data, this.onStreamData);\n    this.stream.off(types_1.ETwitterStreamEvent.ConnectionError, this.onStreamError);\n    this.stream.off(types_1.ETwitterStreamEvent.TweetParseError, this.onStreamError);\n    this.stream.off(types_1.ETwitterStreamEvent.ConnectionClosed, this.onStreamError);\n  }\n  emitEvent(type, payload) {\n    this.emit('event', {\n      type,\n      payload\n    });\n  }\n  onStreamError(payload) {\n    this.emitEvent('error', payload);\n  }\n  onStreamData(payload) {\n    this.stack.push(payload);\n    this.emitEvent('data', payload);\n  }\n}\nexports.TweetStreamEventCombiner = TweetStreamEventCombiner;\nexports.default = TweetStreamEventCombiner;","map":{"version":3,"names":["Object","defineProperty","exports","value","TweetStreamEventCombiner","events_1","require","types_1","EventEmitter","constructor","stream","stack","onStreamData","bind","onStreamError","onceNewEvent","once","on","ETwitterStreamEvent","Data","ConnectionError","TweetParseError","ConnectionClosed","nextEvent","Promise","hasStack","length","popStack","destroy","removeAllListeners","off","emitEvent","type","payload","emit","push","default"],"sources":["/Users/kiyujin/Dev/ringcard/ringcard_frontend/node_modules/twitter-api-v2/dist/stream/TweetStreamEventCombiner.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TweetStreamEventCombiner = void 0;\nconst events_1 = require(\"events\");\nconst types_1 = require(\"../types\");\nclass TweetStreamEventCombiner extends events_1.EventEmitter {\n    constructor(stream) {\n        super();\n        this.stream = stream;\n        this.stack = [];\n        this.onStreamData = this.onStreamData.bind(this);\n        this.onStreamError = this.onStreamError.bind(this);\n        this.onceNewEvent = this.once.bind(this, 'event');\n        // Init events from stream\n        stream.on(types_1.ETwitterStreamEvent.Data, this.onStreamData);\n        // Ignore reconnect errors: Don't close event combiner until connection error/closed\n        stream.on(types_1.ETwitterStreamEvent.ConnectionError, this.onStreamError);\n        stream.on(types_1.ETwitterStreamEvent.TweetParseError, this.onStreamError);\n        stream.on(types_1.ETwitterStreamEvent.ConnectionClosed, this.onStreamError);\n    }\n    /** Returns a new `Promise` that will `resolve` on next event (`data` or any sort of error). */\n    nextEvent() {\n        return new Promise(this.onceNewEvent);\n    }\n    /** Returns `true` if there's something in the stack. */\n    hasStack() {\n        return this.stack.length > 0;\n    }\n    /** Returns stacked data events, and clean the stack. */\n    popStack() {\n        const stack = this.stack;\n        this.stack = [];\n        return stack;\n    }\n    /** Cleanup all the listeners attached on stream. */\n    destroy() {\n        this.removeAllListeners();\n        this.stream.off(types_1.ETwitterStreamEvent.Data, this.onStreamData);\n        this.stream.off(types_1.ETwitterStreamEvent.ConnectionError, this.onStreamError);\n        this.stream.off(types_1.ETwitterStreamEvent.TweetParseError, this.onStreamError);\n        this.stream.off(types_1.ETwitterStreamEvent.ConnectionClosed, this.onStreamError);\n    }\n    emitEvent(type, payload) {\n        this.emit('event', { type, payload });\n    }\n    onStreamError(payload) {\n        this.emitEvent('error', payload);\n    }\n    onStreamData(payload) {\n        this.stack.push(payload);\n        this.emitEvent('data', payload);\n    }\n}\nexports.TweetStreamEventCombiner = TweetStreamEventCombiner;\nexports.default = TweetStreamEventCombiner;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}