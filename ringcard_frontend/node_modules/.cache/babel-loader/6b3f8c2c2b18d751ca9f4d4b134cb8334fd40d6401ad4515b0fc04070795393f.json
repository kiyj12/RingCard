{"ast":null,"code":"const jose = require('jose');\nconst {\n  RPError\n} = require('../errors');\nconst {\n  assertIssuerConfiguration\n} = require('./assert');\nconst {\n  random\n} = require('./generators');\nconst now = require('./unix_timestamp');\nconst request = require('./request');\nconst {\n  keystores\n} = require('./weak_cache');\nconst merge = require('./merge');\nconst formUrlEncode = value => encodeURIComponent(value).replace(/%20/g, '+');\nasync function clientAssertion(endpoint, payload) {\n  let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n  if (!alg) {\n    assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);\n  }\n  if (this[`${endpoint}_endpoint_auth_method`] === 'client_secret_jwt') {\n    if (!alg) {\n      const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n      alg = Array.isArray(supported) && supported.find(signAlg => /^HS(?:256|384|512)/.test(signAlg));\n    }\n    if (!alg) {\n      throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);\n    }\n    return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({\n      alg\n    }).sign(this.secretForAlg(alg));\n  }\n  const keystore = await keystores.get(this);\n  if (!keystore) {\n    throw new TypeError('no client jwks provided for signing a client assertion with');\n  }\n  if (!alg) {\n    const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n    alg = Array.isArray(supported) && supported.find(signAlg => keystore.get({\n      alg: signAlg,\n      use: 'sig'\n    }));\n  }\n  if (!alg) {\n    throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);\n  }\n  const key = keystore.get({\n    alg,\n    use: 'sig'\n  });\n  if (!key) {\n    throw new RPError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);\n  }\n  return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({\n    alg,\n    kid: key.jwk && key.jwk.kid\n  }).sign(key.keyObject);\n}\nasync function authFor(endpoint) {\n  let {\n    clientAssertionPayload\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const authMethod = this[`${endpoint}_endpoint_auth_method`];\n  switch (authMethod) {\n    case 'self_signed_tls_client_auth':\n    case 'tls_client_auth':\n    case 'none':\n      return {\n        form: {\n          client_id: this.client_id\n        }\n      };\n    case 'client_secret_post':\n      if (!this.client_secret) {\n        throw new TypeError('client_secret_post client authentication method requires a client_secret');\n      }\n      return {\n        form: {\n          client_id: this.client_id,\n          client_secret: this.client_secret\n        }\n      };\n    case 'private_key_jwt':\n    case 'client_secret_jwt':\n      {\n        const timestamp = now();\n        const audience = [...new Set([this.issuer.issuer, this.issuer.token_endpoint].filter(Boolean))];\n        const assertion = await clientAssertion.call(this, endpoint, {\n          iat: timestamp,\n          exp: timestamp + 60,\n          jti: random(),\n          iss: this.client_id,\n          sub: this.client_id,\n          aud: audience,\n          ...clientAssertionPayload\n        });\n        return {\n          form: {\n            client_id: this.client_id,\n            client_assertion: assertion,\n            client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'\n          }\n        };\n      }\n    case 'client_secret_basic':\n      {\n        // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n        // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n        // > The client identifier is encoded using the\n        // > \"application/x-www-form-urlencoded\" encoding algorithm per\n        // > Appendix B, and the encoded value is used as the username; the client\n        // > password is encoded using the same algorithm and used as the\n        // > password.\n        if (!this.client_secret) {\n          throw new TypeError('client_secret_basic client authentication method requires a client_secret');\n        }\n        const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n        const value = Buffer.from(encoded).toString('base64');\n        return {\n          headers: {\n            Authorization: `Basic ${value}`\n          }\n        };\n      }\n    default:\n      {\n        throw new TypeError(`missing, or unsupported, ${endpoint}_endpoint_auth_method`);\n      }\n  }\n}\nfunction resolveResponseType() {\n  const {\n    length,\n    0: value\n  } = this.response_types;\n  if (length === 1) {\n    return value;\n  }\n  return undefined;\n}\nfunction resolveRedirectUri() {\n  const {\n    length,\n    0: value\n  } = this.redirect_uris || [];\n  if (length === 1) {\n    return value;\n  }\n  return undefined;\n}\nasync function authenticatedPost(endpoint, opts) {\n  let {\n    clientAssertionPayload,\n    endpointAuthMethod = endpoint,\n    DPoP\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const auth = await authFor.call(this, endpointAuthMethod, {\n    clientAssertionPayload\n  });\n  const requestOpts = merge(opts, auth);\n  const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes('tls_client_auth') || endpoint === 'token' && this.tls_client_certificate_bound_access_tokens;\n  let targetUrl;\n  if (mTLS && this.issuer.mtls_endpoint_aliases) {\n    targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n  }\n  targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n  if ('form' in requestOpts) {\n    for (const [key, value] of Object.entries(requestOpts.form)) {\n      if (typeof value === 'undefined') {\n        delete requestOpts.form[key];\n      }\n    }\n  }\n  return request.call(this, {\n    ...requestOpts,\n    method: 'POST',\n    url: targetUrl,\n    headers: {\n      ...(endpoint !== 'revocation' ? {\n        Accept: 'application/json'\n      } : undefined),\n      ...requestOpts.headers\n    }\n  }, {\n    mTLS,\n    DPoP\n  });\n}\nmodule.exports = {\n  resolveResponseType,\n  resolveRedirectUri,\n  authFor,\n  authenticatedPost\n};","map":{"version":3,"names":["jose","require","RPError","assertIssuerConfiguration","random","now","request","keystores","merge","formUrlEncode","value","encodeURIComponent","replace","clientAssertion","endpoint","payload","alg","issuer","supported","Array","isArray","find","signAlg","test","CompactSign","Buffer","from","JSON","stringify","setProtectedHeader","sign","secretForAlg","keystore","get","TypeError","use","key","kid","jwk","keyObject","authFor","clientAssertionPayload","authMethod","form","client_id","client_secret","timestamp","audience","Set","token_endpoint","filter","Boolean","assertion","call","iat","exp","jti","iss","sub","aud","client_assertion","client_assertion_type","encoded","toString","headers","Authorization","resolveResponseType","length","response_types","undefined","resolveRedirectUri","redirect_uris","authenticatedPost","opts","endpointAuthMethod","DPoP","auth","requestOpts","mTLS","includes","tls_client_certificate_bound_access_tokens","targetUrl","mtls_endpoint_aliases","Object","entries","method","url","Accept","module","exports"],"sources":["C:/Users/yuleg/Dev/Ringca/ORIN33/ringcard/ringcard_frontend/node_modules/openid-client/lib/helpers/client.js"],"sourcesContent":["const jose = require('jose');\n\nconst { RPError } = require('../errors');\n\nconst { assertIssuerConfiguration } = require('./assert');\nconst { random } = require('./generators');\nconst now = require('./unix_timestamp');\nconst request = require('./request');\nconst { keystores } = require('./weak_cache');\nconst merge = require('./merge');\n\nconst formUrlEncode = (value) => encodeURIComponent(value).replace(/%20/g, '+');\n\nasync function clientAssertion(endpoint, payload) {\n  let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n  if (!alg) {\n    assertIssuerConfiguration(\n      this.issuer,\n      `${endpoint}_endpoint_auth_signing_alg_values_supported`,\n    );\n  }\n\n  if (this[`${endpoint}_endpoint_auth_method`] === 'client_secret_jwt') {\n    if (!alg) {\n      const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n      alg =\n        Array.isArray(supported) && supported.find((signAlg) => /^HS(?:256|384|512)/.test(signAlg));\n    }\n\n    if (!alg) {\n      throw new RPError(\n        `failed to determine a JWS Algorithm to use for ${\n          this[`${endpoint}_endpoint_auth_method`]\n        } Client Assertion`,\n      );\n    }\n\n    return new jose.CompactSign(Buffer.from(JSON.stringify(payload)))\n      .setProtectedHeader({ alg })\n      .sign(this.secretForAlg(alg));\n  }\n\n  const keystore = await keystores.get(this);\n\n  if (!keystore) {\n    throw new TypeError('no client jwks provided for signing a client assertion with');\n  }\n\n  if (!alg) {\n    const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n    alg =\n      Array.isArray(supported) &&\n      supported.find((signAlg) => keystore.get({ alg: signAlg, use: 'sig' }));\n  }\n\n  if (!alg) {\n    throw new RPError(\n      `failed to determine a JWS Algorithm to use for ${\n        this[`${endpoint}_endpoint_auth_method`]\n      } Client Assertion`,\n    );\n  }\n\n  const key = keystore.get({ alg, use: 'sig' });\n  if (!key) {\n    throw new RPError(\n      `no key found in client jwks to sign a client assertion with using alg ${alg}`,\n    );\n  }\n\n  return new jose.CompactSign(Buffer.from(JSON.stringify(payload)))\n    .setProtectedHeader({ alg, kid: key.jwk && key.jwk.kid })\n    .sign(key.keyObject);\n}\n\nasync function authFor(endpoint, { clientAssertionPayload } = {}) {\n  const authMethod = this[`${endpoint}_endpoint_auth_method`];\n  switch (authMethod) {\n    case 'self_signed_tls_client_auth':\n    case 'tls_client_auth':\n    case 'none':\n      return { form: { client_id: this.client_id } };\n    case 'client_secret_post':\n      if (!this.client_secret) {\n        throw new TypeError(\n          'client_secret_post client authentication method requires a client_secret',\n        );\n      }\n      return { form: { client_id: this.client_id, client_secret: this.client_secret } };\n    case 'private_key_jwt':\n    case 'client_secret_jwt': {\n      const timestamp = now();\n      const audience = [\n        ...new Set([this.issuer.issuer, this.issuer.token_endpoint].filter(Boolean)),\n      ];\n\n      const assertion = await clientAssertion.call(this, endpoint, {\n        iat: timestamp,\n        exp: timestamp + 60,\n        jti: random(),\n        iss: this.client_id,\n        sub: this.client_id,\n        aud: audience,\n        ...clientAssertionPayload,\n      });\n\n      return {\n        form: {\n          client_id: this.client_id,\n          client_assertion: assertion,\n          client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',\n        },\n      };\n    }\n    case 'client_secret_basic': {\n      // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n      // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n      // > The client identifier is encoded using the\n      // > \"application/x-www-form-urlencoded\" encoding algorithm per\n      // > Appendix B, and the encoded value is used as the username; the client\n      // > password is encoded using the same algorithm and used as the\n      // > password.\n      if (!this.client_secret) {\n        throw new TypeError(\n          'client_secret_basic client authentication method requires a client_secret',\n        );\n      }\n      const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n      const value = Buffer.from(encoded).toString('base64');\n      return { headers: { Authorization: `Basic ${value}` } };\n    }\n    default: {\n      throw new TypeError(`missing, or unsupported, ${endpoint}_endpoint_auth_method`);\n    }\n  }\n}\n\nfunction resolveResponseType() {\n  const { length, 0: value } = this.response_types;\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nfunction resolveRedirectUri() {\n  const { length, 0: value } = this.redirect_uris || [];\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nasync function authenticatedPost(\n  endpoint,\n  opts,\n  { clientAssertionPayload, endpointAuthMethod = endpoint, DPoP } = {},\n) {\n  const auth = await authFor.call(this, endpointAuthMethod, { clientAssertionPayload });\n  const requestOpts = merge(opts, auth);\n\n  const mTLS =\n    this[`${endpointAuthMethod}_endpoint_auth_method`].includes('tls_client_auth') ||\n    (endpoint === 'token' && this.tls_client_certificate_bound_access_tokens);\n\n  let targetUrl;\n  if (mTLS && this.issuer.mtls_endpoint_aliases) {\n    targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n  }\n\n  targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n\n  if ('form' in requestOpts) {\n    for (const [key, value] of Object.entries(requestOpts.form)) {\n      if (typeof value === 'undefined') {\n        delete requestOpts.form[key];\n      }\n    }\n  }\n\n  return request.call(\n    this,\n    {\n      ...requestOpts,\n      method: 'POST',\n      url: targetUrl,\n      headers: {\n        ...(endpoint !== 'revocation'\n          ? {\n              Accept: 'application/json',\n            }\n          : undefined),\n        ...requestOpts.headers,\n      },\n    },\n    { mTLS, DPoP },\n  );\n}\n\nmodule.exports = {\n  resolveResponseType,\n  resolveRedirectUri,\n  authFor,\n  authenticatedPost,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}