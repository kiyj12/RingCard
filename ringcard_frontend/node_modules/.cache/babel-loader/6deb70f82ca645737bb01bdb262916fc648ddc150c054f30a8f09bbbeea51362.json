{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PreviousableTwitterPaginator = exports.TwitterPaginator = void 0;\n/** TwitterPaginator: able to get consume data from initial request, then fetch next data sequentially. */\nclass TwitterPaginator {\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor(_ref) {\n    let {\n      realData,\n      rateLimit,\n      instance,\n      queryParams,\n      sharedParams\n    } = _ref;\n    this._maxResultsWhenFetchLast = 100;\n    this._realData = realData;\n    this._rateLimit = rateLimit;\n    this._instance = instance;\n    this._queryParams = queryParams;\n    this._sharedParams = sharedParams;\n  }\n  get _isRateLimitOk() {\n    if (!this._rateLimit) {\n      return true;\n    }\n    const resetDate = this._rateLimit.reset * 1000;\n    if (resetDate < Date.now()) {\n      return true;\n    }\n    return this._rateLimit.remaining > 0;\n  }\n  makeRequest(queryParams) {\n    return this._instance.get(this.getEndpoint(), queryParams, {\n      fullResponse: true,\n      params: this._sharedParams\n    });\n  }\n  makeNewInstanceFromResult(result, queryParams) {\n    // Construct a subclass\n    return new this.constructor({\n      realData: result.data,\n      rateLimit: result.rateLimit,\n      instance: this._instance,\n      queryParams,\n      sharedParams: this._sharedParams\n    });\n  }\n  getEndpoint() {\n    return this._endpoint;\n  }\n  injectQueryParams(maxResults) {\n    return {\n      ...(maxResults ? {\n        max_results: maxResults\n      } : {}),\n      ...this._queryParams\n    };\n  }\n  /* ---------------------- */\n  /* Real paginator methods */\n  /* ---------------------- */\n  /**\n   * Next page.\n   */\n  async next(maxResults) {\n    const queryParams = this.getNextQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams);\n    return this.makeNewInstanceFromResult(result, queryParams);\n  }\n  /**\n   * Next page, but store it in current instance.\n   */\n  async fetchNext(maxResults) {\n    const queryParams = this.getNextQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams);\n    // Await in case of async sub-methods\n    await this.refreshInstanceFromResult(result, true);\n    return this;\n  }\n  /**\n   * Fetch up to {count} items after current page,\n   * as long as rate limit is not hit and Twitter has some results\n   */\n  async fetchLast() {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n    let queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n    let resultCount = 0;\n    // Break at rate limit limit\n    while (resultCount < count && this._isRateLimitOk) {\n      const response = await this.makeRequest(queryParams);\n      await this.refreshInstanceFromResult(response, true);\n      resultCount += this.getPageLengthFromRequest(response);\n      if (this.isFetchLastOver(response)) {\n        break;\n      }\n      queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n    }\n    return this;\n  }\n  get rateLimit() {\n    var _a;\n    return {\n      ...((_a = this._rateLimit) !== null && _a !== void 0 ? _a : {})\n    };\n  }\n  /** Get raw data returned by Twitter API. */\n  get data() {\n    return this._realData;\n  }\n  get done() {\n    return !this.canFetchNextPage(this._realData);\n  }\n  /**\n   * Iterate over currently fetched items.\n   */\n  *[Symbol.iterator]() {\n    yield* this.getItemArray();\n  }\n  /**\n   * Iterate over items \"undefinitely\" (until rate limit is hit / they're no more items available)\n   * This will **mutate the current instance** and fill data, metas, etc. inside this instance.\n   *\n   * If you need to handle concurrent requests, or you need to rely on immutability, please use `.fetchAndIterate()` instead.\n   */\n  async *[Symbol.asyncIterator]() {\n    yield* this.getItemArray();\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let paginator = this;\n    let canFetchNextPage = this.canFetchNextPage(this._realData);\n    while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n      const next = await paginator.next(this._maxResultsWhenFetchLast);\n      // Store data into current instance [needed to access includes and meta]\n      this.refreshInstanceFromResult({\n        data: next._realData,\n        headers: {},\n        rateLimit: next._rateLimit\n      }, true);\n      canFetchNextPage = this.canFetchNextPage(next._realData);\n      const items = next.getItemArray();\n      yield* items;\n      paginator = next;\n    }\n  }\n  /**\n   * Iterate over items \"undefinitely\" without modifying the current instance (until rate limit is hit / they're no more items available)\n   *\n   * This will **NOT** mutate the current instance, meaning that current instance will not inherit from `includes` and `meta` (v2 API only).\n   * Use `Symbol.asyncIterator` (`for-await of`) to directly access items with current instance mutation.\n   */\n  async *fetchAndIterate() {\n    for (const item of this.getItemArray()) {\n      yield [item, this];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let paginator = this;\n    let canFetchNextPage = this.canFetchNextPage(this._realData);\n    while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n      const next = await paginator.next(this._maxResultsWhenFetchLast);\n      // Store data into current instance [needed to access includes and meta]\n      this.refreshInstanceFromResult({\n        data: next._realData,\n        headers: {},\n        rateLimit: next._rateLimit\n      }, true);\n      canFetchNextPage = this.canFetchNextPage(next._realData);\n      for (const item of next.getItemArray()) {\n        yield [item, next];\n      }\n      this._rateLimit = next._rateLimit;\n      paginator = next;\n    }\n  }\n}\nexports.TwitterPaginator = TwitterPaginator;\n/** PreviousableTwitterPaginator: a TwitterPaginator able to get consume data from both side, next and previous. */\nclass PreviousableTwitterPaginator extends TwitterPaginator {\n  /**\n   * Previous page (new tweets)\n   */\n  async previous(maxResults) {\n    const queryParams = this.getPreviousQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams);\n    return this.makeNewInstanceFromResult(result, queryParams);\n  }\n  /**\n   * Previous page, but in current instance.\n   */\n  async fetchPrevious(maxResults) {\n    const queryParams = this.getPreviousQueryParams(maxResults);\n    const result = await this.makeRequest(queryParams);\n    await this.refreshInstanceFromResult(result, false);\n    return this;\n  }\n}\nexports.PreviousableTwitterPaginator = PreviousableTwitterPaginator;\nexports.default = TwitterPaginator;","map":{"version":3,"names":["Object","defineProperty","exports","value","PreviousableTwitterPaginator","TwitterPaginator","constructor","realData","rateLimit","instance","queryParams","sharedParams","_maxResultsWhenFetchLast","_realData","_rateLimit","_instance","_queryParams","_sharedParams","_isRateLimitOk","resetDate","reset","Date","now","remaining","makeRequest","get","getEndpoint","fullResponse","params","makeNewInstanceFromResult","result","data","_endpoint","injectQueryParams","maxResults","max_results","next","getNextQueryParams","fetchNext","refreshInstanceFromResult","fetchLast","count","Infinity","resultCount","response","getPageLengthFromRequest","isFetchLastOver","_a","done","canFetchNextPage","Symbol","iterator","getItemArray","asyncIterator","paginator","length","headers","items","fetchAndIterate","item","previous","getPreviousQueryParams","fetchPrevious","default"],"sources":["C:/Users/yuleg/Dev/Ringca/ORIN33/ringcard/ringcard_frontend/node_modules/twitter-api-v2/dist/paginators/TwitterPaginator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PreviousableTwitterPaginator = exports.TwitterPaginator = void 0;\n/** TwitterPaginator: able to get consume data from initial request, then fetch next data sequentially. */\nclass TwitterPaginator {\n    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n    constructor({ realData, rateLimit, instance, queryParams, sharedParams }) {\n        this._maxResultsWhenFetchLast = 100;\n        this._realData = realData;\n        this._rateLimit = rateLimit;\n        this._instance = instance;\n        this._queryParams = queryParams;\n        this._sharedParams = sharedParams;\n    }\n    get _isRateLimitOk() {\n        if (!this._rateLimit) {\n            return true;\n        }\n        const resetDate = this._rateLimit.reset * 1000;\n        if (resetDate < Date.now()) {\n            return true;\n        }\n        return this._rateLimit.remaining > 0;\n    }\n    makeRequest(queryParams) {\n        return this._instance.get(this.getEndpoint(), queryParams, { fullResponse: true, params: this._sharedParams });\n    }\n    makeNewInstanceFromResult(result, queryParams) {\n        // Construct a subclass\n        return new this.constructor({\n            realData: result.data,\n            rateLimit: result.rateLimit,\n            instance: this._instance,\n            queryParams,\n            sharedParams: this._sharedParams,\n        });\n    }\n    getEndpoint() {\n        return this._endpoint;\n    }\n    injectQueryParams(maxResults) {\n        return {\n            ...(maxResults ? { max_results: maxResults } : {}),\n            ...this._queryParams,\n        };\n    }\n    /* ---------------------- */\n    /* Real paginator methods */\n    /* ---------------------- */\n    /**\n     * Next page.\n     */\n    async next(maxResults) {\n        const queryParams = this.getNextQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        return this.makeNewInstanceFromResult(result, queryParams);\n    }\n    /**\n     * Next page, but store it in current instance.\n     */\n    async fetchNext(maxResults) {\n        const queryParams = this.getNextQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        // Await in case of async sub-methods\n        await this.refreshInstanceFromResult(result, true);\n        return this;\n    }\n    /**\n     * Fetch up to {count} items after current page,\n     * as long as rate limit is not hit and Twitter has some results\n     */\n    async fetchLast(count = Infinity) {\n        let queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n        let resultCount = 0;\n        // Break at rate limit limit\n        while (resultCount < count && this._isRateLimitOk) {\n            const response = await this.makeRequest(queryParams);\n            await this.refreshInstanceFromResult(response, true);\n            resultCount += this.getPageLengthFromRequest(response);\n            if (this.isFetchLastOver(response)) {\n                break;\n            }\n            queryParams = this.getNextQueryParams(this._maxResultsWhenFetchLast);\n        }\n        return this;\n    }\n    get rateLimit() {\n        var _a;\n        return { ...(_a = this._rateLimit) !== null && _a !== void 0 ? _a : {} };\n    }\n    /** Get raw data returned by Twitter API. */\n    get data() {\n        return this._realData;\n    }\n    get done() {\n        return !this.canFetchNextPage(this._realData);\n    }\n    /**\n     * Iterate over currently fetched items.\n     */\n    *[Symbol.iterator]() {\n        yield* this.getItemArray();\n    }\n    /**\n     * Iterate over items \"undefinitely\" (until rate limit is hit / they're no more items available)\n     * This will **mutate the current instance** and fill data, metas, etc. inside this instance.\n     *\n     * If you need to handle concurrent requests, or you need to rely on immutability, please use `.fetchAndIterate()` instead.\n     */\n    async *[Symbol.asyncIterator]() {\n        yield* this.getItemArray();\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let paginator = this;\n        let canFetchNextPage = this.canFetchNextPage(this._realData);\n        while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n            const next = await paginator.next(this._maxResultsWhenFetchLast);\n            // Store data into current instance [needed to access includes and meta]\n            this.refreshInstanceFromResult({ data: next._realData, headers: {}, rateLimit: next._rateLimit }, true);\n            canFetchNextPage = this.canFetchNextPage(next._realData);\n            const items = next.getItemArray();\n            yield* items;\n            paginator = next;\n        }\n    }\n    /**\n     * Iterate over items \"undefinitely\" without modifying the current instance (until rate limit is hit / they're no more items available)\n     *\n     * This will **NOT** mutate the current instance, meaning that current instance will not inherit from `includes` and `meta` (v2 API only).\n     * Use `Symbol.asyncIterator` (`for-await of`) to directly access items with current instance mutation.\n     */\n    async *fetchAndIterate() {\n        for (const item of this.getItemArray()) {\n            yield [item, this];\n        }\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let paginator = this;\n        let canFetchNextPage = this.canFetchNextPage(this._realData);\n        while (canFetchNextPage && this._isRateLimitOk && paginator.getItemArray().length > 0) {\n            const next = await paginator.next(this._maxResultsWhenFetchLast);\n            // Store data into current instance [needed to access includes and meta]\n            this.refreshInstanceFromResult({ data: next._realData, headers: {}, rateLimit: next._rateLimit }, true);\n            canFetchNextPage = this.canFetchNextPage(next._realData);\n            for (const item of next.getItemArray()) {\n                yield [item, next];\n            }\n            this._rateLimit = next._rateLimit;\n            paginator = next;\n        }\n    }\n}\nexports.TwitterPaginator = TwitterPaginator;\n/** PreviousableTwitterPaginator: a TwitterPaginator able to get consume data from both side, next and previous. */\nclass PreviousableTwitterPaginator extends TwitterPaginator {\n    /**\n     * Previous page (new tweets)\n     */\n    async previous(maxResults) {\n        const queryParams = this.getPreviousQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        return this.makeNewInstanceFromResult(result, queryParams);\n    }\n    /**\n     * Previous page, but in current instance.\n     */\n    async fetchPrevious(maxResults) {\n        const queryParams = this.getPreviousQueryParams(maxResults);\n        const result = await this.makeRequest(queryParams);\n        await this.refreshInstanceFromResult(result, false);\n        return this;\n    }\n}\nexports.PreviousableTwitterPaginator = PreviousableTwitterPaginator;\nexports.default = TwitterPaginator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}