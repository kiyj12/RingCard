{"ast":null,"code":"const {\n  inspect\n} = require('util');\nconst stdhttp = require('http');\nconst crypto = require('crypto');\nconst {\n  strict: assert\n} = require('assert');\nconst querystring = require('querystring');\nconst url = require('url');\nconst jose = require('jose');\nconst tokenHash = require('oidc-token-hash');\nconst isKeyObject = require('./helpers/is_key_object');\nconst decodeJWT = require('./helpers/decode_jwt');\nconst base64url = require('./helpers/base64url');\nconst defaults = require('./helpers/defaults');\nconst parseWwwAuthenticate = require('./helpers/www_authenticate_parser');\nconst {\n  assertSigningAlgValuesSupport,\n  assertIssuerConfiguration\n} = require('./helpers/assert');\nconst pick = require('./helpers/pick');\nconst isPlainObject = require('./helpers/is_plain_object');\nconst processResponse = require('./helpers/process_response');\nconst TokenSet = require('./token_set');\nconst {\n  OPError,\n  RPError\n} = require('./errors');\nconst now = require('./helpers/unix_timestamp');\nconst {\n  random\n} = require('./helpers/generators');\nconst request = require('./helpers/request');\nconst {\n  CLOCK_TOLERANCE\n} = require('./helpers/consts');\nconst {\n  keystores\n} = require('./helpers/weak_cache');\nconst KeyStore = require('./helpers/keystore');\nconst clone = require('./helpers/deep_clone');\nconst {\n  authenticatedPost,\n  resolveResponseType,\n  resolveRedirectUri\n} = require('./helpers/client');\nconst {\n  queryKeyStore\n} = require('./helpers/issuer');\nconst DeviceFlowHandle = require('./device_flow_handle');\nconst [major, minor] = process.version.slice(1).split('.').map(str => parseInt(str, 10));\nconst rsaPssParams = major >= 17 || major === 16 && minor >= 9;\nconst retryAttempt = Symbol();\nconst skipNonceCheck = Symbol();\nconst skipMaxAgeCheck = Symbol();\nfunction pickCb(input) {\n  return pick(input, 'access_token',\n  // OAuth 2.0\n  'code',\n  // OAuth 2.0\n  'error_description',\n  // OAuth 2.0\n  'error_uri',\n  // OAuth 2.0\n  'error',\n  // OAuth 2.0\n  'expires_in',\n  // OAuth 2.0\n  'id_token',\n  // OIDC Core 1.0\n  'iss',\n  // draft-ietf-oauth-iss-auth-resp\n  'response',\n  // FAPI JARM\n  'session_state',\n  // OIDC Session Management\n  'state',\n  // OAuth 2.0\n  'token_type' // OAuth 2.0\n  );\n}\n\nfunction authorizationHeaderValue(token) {\n  let tokenType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Bearer';\n  return `${tokenType} ${token}`;\n}\nfunction verifyPresence(payload, jwt, prop) {\n  if (payload[prop] === undefined) {\n    throw new RPError({\n      message: `missing required JWT property ${prop}`,\n      jwt\n    });\n  }\n}\nfunction authorizationParams(params) {\n  const authParams = {\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: resolveResponseType.call(this),\n    redirect_uri: resolveRedirectUri.call(this),\n    ...params\n  };\n  Object.entries(authParams).forEach(_ref => {\n    let [key, value] = _ref;\n    if (value === null || value === undefined) {\n      delete authParams[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      authParams[key] = JSON.stringify(value);\n    } else if (key === 'resource' && Array.isArray(value)) {\n      authParams[key] = value;\n    } else if (typeof value !== 'string') {\n      authParams[key] = String(value);\n    }\n  });\n  return authParams;\n}\nfunction getKeystore(jwks) {\n  if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some(k => !isPlainObject(k) || !('kty' in k))) {\n    throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n  }\n  return KeyStore.fromJWKS(jwks, {\n    onlyPrivate: true\n  });\n}\n\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\nfunction handleCommonMistakes(client, metadata, properties) {\n  if (!metadata.token_endpoint_auth_method) {\n    // if no explicit value was provided\n    checkBasicSupport(client, properties);\n  }\n\n  // :fp: c'mon people... RTFM\n  if (metadata.redirect_uri) {\n    if (metadata.redirect_uris) {\n      throw new TypeError('provide a redirect_uri or redirect_uris, not both');\n    }\n    properties.redirect_uris = [metadata.redirect_uri];\n    delete properties.redirect_uri;\n  }\n  if (metadata.response_type) {\n    if (metadata.response_types) {\n      throw new TypeError('provide a response_type or response_types, not both');\n    }\n    properties.response_types = [metadata.response_type];\n    delete properties.response_type;\n  }\n}\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n  if (properties[eam] === undefined && properties[easa] === undefined) {\n    if (tokenEndpointAuthMethod !== undefined) {\n      properties[eam] = tokenEndpointAuthMethod;\n    }\n    if (tokenEndpointAuthSigningAlg !== undefined) {\n      properties[easa] = tokenEndpointAuthSigningAlg;\n    }\n  }\n}\nclass BaseClient {\n  #metadata;\n  #issuer;\n  #aadIssValidation;\n  #additionalAuthorizedParties;\n  constructor(issuer, aadIssValidation) {\n    let metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let jwks = arguments.length > 3 ? arguments[3] : undefined;\n    let options = arguments.length > 4 ? arguments[4] : undefined;\n    this.#metadata = new Map();\n    this.#issuer = issuer;\n    this.#aadIssValidation = aadIssValidation;\n    if (typeof metadata.client_id !== 'string' || !metadata.client_id) {\n      throw new TypeError('client_id is required');\n    }\n    const properties = {\n      grant_types: ['authorization_code'],\n      id_token_signed_response_alg: 'RS256',\n      authorization_signed_response_alg: 'RS256',\n      response_types: ['code'],\n      token_endpoint_auth_method: 'client_secret_basic',\n      ...(this.fapi() ? {\n        grant_types: ['authorization_code', 'implicit'],\n        id_token_signed_response_alg: 'PS256',\n        authorization_signed_response_alg: 'PS256',\n        response_types: ['code id_token'],\n        tls_client_certificate_bound_access_tokens: true,\n        token_endpoint_auth_method: undefined\n      } : undefined),\n      ...metadata\n    };\n    if (this.fapi()) {\n      switch (properties.token_endpoint_auth_method) {\n        case 'self_signed_tls_client_auth':\n        case 'tls_client_auth':\n          break;\n        case 'private_key_jwt':\n          if (!jwks) {\n            throw new TypeError('jwks is required');\n          }\n          break;\n        case undefined:\n          throw new TypeError('token_endpoint_auth_method is required');\n        default:\n          throw new TypeError('invalid or unsupported token_endpoint_auth_method');\n      }\n    }\n    handleCommonMistakes(this, metadata, properties);\n    assertSigningAlgValuesSupport('token', this.issuer, properties);\n    ['introspection', 'revocation'].forEach(endpoint => {\n      getDefaultsForEndpoint(endpoint, this.issuer, properties);\n      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n    });\n    Object.entries(properties).forEach(_ref2 => {\n      let [key, value] = _ref2;\n      this.#metadata.set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return this.#metadata.get(key);\n          },\n          enumerable: true\n        });\n      }\n    });\n    if (jwks !== undefined) {\n      const keystore = getKeystore.call(this, jwks);\n      keystores.set(this, keystore);\n    }\n    if (options != null && options.additionalAuthorizedParties) {\n      this.#additionalAuthorizedParties = clone(options.additionalAuthorizedParties);\n    }\n    this[CLOCK_TOLERANCE] = 0;\n  }\n  authorizationUrl() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    target.query = {\n      ...target.query,\n      ...authorizationParams.call(this, params)\n    };\n    return url.format(target);\n  }\n  authorizationPost() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs).map(name => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n    return `<!DOCTYPE html>\n<head>\n<title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n<form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n  ${formInputs}\n</form>\n</body>\n</html>`;\n  }\n  endSessionUrl() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n    const {\n      0: postLogout,\n      length\n    } = this.post_logout_redirect_uris || [];\n    const {\n      post_logout_redirect_uri = length === 1 ? postLogout : undefined\n    } = params;\n    let id_token_hint;\n    ({\n      id_token_hint,\n      ...params\n    } = params);\n    if (id_token_hint instanceof TokenSet) {\n      if (!id_token_hint.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      id_token_hint = id_token_hint.id_token;\n    }\n    const target = url.parse(this.issuer.end_session_endpoint, true);\n    target.search = null;\n    defaults(target.query, params, {\n      post_logout_redirect_uri,\n      client_id: this.client_id\n    }, {\n      id_token_hint\n    });\n    Object.entries(target.query).forEach(_ref3 => {\n      let [key, value] = _ref3;\n      if (value === null || value === undefined) {\n        delete target.query[key];\n      }\n    });\n    return url.format(target);\n  }\n  callbackParams(input) {\n    const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;\n    const isString = typeof input === 'string';\n    if (!isString && !isIncomingMessage) {\n      throw new TypeError('#callbackParams only accepts string urls, http.IncomingMessage or a lookalike');\n    }\n    if (isIncomingMessage) {\n      switch (input.method) {\n        case 'GET':\n          return pickCb(url.parse(input.url, true).query);\n        case 'POST':\n          if (input.body === undefined) {\n            throw new TypeError('incoming message body missing, include a body parser prior to this method call');\n          }\n          switch (typeof input.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(input.body)) {\n                return pickCb(querystring.parse(input.body.toString('utf-8')));\n              }\n              if (typeof input.body === 'string') {\n                return pickCb(querystring.parse(input.body));\n              }\n              return pickCb(input.body);\n            default:\n              throw new TypeError('invalid IncomingMessage body object');\n          }\n        default:\n          throw new TypeError('invalid IncomingMessage method');\n      }\n    } else {\n      return pickCb(url.parse(input, true).query);\n    }\n  }\n  async callback(redirectUri, parameters) {\n    let checks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let {\n      exchangeBody,\n      clientAssertionPayload,\n      DPoP\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let params = pickCb(parameters);\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n    if (this.default_max_age && !checks.max_age) {\n      checks.max_age = this.default_max_age;\n    }\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params\n      });\n    }\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params\n      });\n    }\n    if ('iss' in params) {\n      assertIssuerConfiguration(this.issuer, 'issuer');\n      if (params.iss !== this.issuer.issuer) {\n        throw new RPError({\n          printf: ['iss mismatch, expected %s, got: %s', this.issuer.issuer, params.iss],\n          params\n        });\n      }\n    } else if (this.issuer.authorization_response_iss_parameter_supported && !('id_token' in params) && !('response' in parameters)) {\n      throw new RPError({\n        message: 'iss missing from the response',\n        params\n      });\n    }\n    if (params.error) {\n      throw new OPError(params);\n    }\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      id_token: ['id_token'],\n      token: ['access_token', 'token_type']\n    };\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params\n            });\n          }\n        } else {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params\n              });\n            }\n          }\n        }\n      }\n    }\n    if (params.id_token) {\n      const tokenset = new TokenSet(params);\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state);\n      if (!params.code) {\n        return tokenset;\n      }\n    }\n    if (params.code) {\n      const tokenset = await this.grant({\n        ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      }, {\n        clientAssertionPayload,\n        DPoP\n      });\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);\n      if (params.session_state) {\n        tokenset.session_state = params.session_state;\n      }\n      return tokenset;\n    }\n    return new TokenSet(params);\n  }\n  async oauthCallback(redirectUri, parameters) {\n    let checks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let {\n      exchangeBody,\n      clientAssertionPayload,\n      DPoP\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let params = pickCb(parameters);\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params\n      });\n    }\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params\n      });\n    }\n    if ('iss' in params) {\n      assertIssuerConfiguration(this.issuer, 'issuer');\n      if (params.iss !== this.issuer.issuer) {\n        throw new RPError({\n          printf: ['iss mismatch, expected %s, got: %s', this.issuer.issuer, params.iss],\n          params\n        });\n      }\n    } else if (this.issuer.authorization_response_iss_parameter_supported && !('id_token' in params) && !('response' in parameters)) {\n      throw new RPError({\n        message: 'iss missing from the response',\n        params\n      });\n    }\n    if (params.error) {\n      throw new OPError(params);\n    }\n    if (typeof params.id_token === 'string' && params.id_token.length) {\n      throw new RPError({\n        message: 'id_token detected in the response, you must use client.callback() instead of client.oauthCallback()',\n        params\n      });\n    }\n    delete params.id_token;\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      token: ['access_token', 'token_type']\n    };\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params\n            });\n          }\n        }\n        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params\n              });\n            }\n          }\n        }\n      }\n    }\n    if (params.code) {\n      const tokenset = await this.grant({\n        ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      }, {\n        clientAssertionPayload,\n        DPoP\n      });\n      if (typeof tokenset.id_token === 'string' && tokenset.id_token.length) {\n        throw new RPError({\n          message: 'id_token detected in the response, you must use client.callback() instead of client.oauthCallback()',\n          params\n        });\n      }\n      delete tokenset.id_token;\n      return tokenset;\n    }\n    return new TokenSet(params);\n  }\n  async decryptIdToken(token) {\n    if (!this.id_token_encrypted_response_alg) {\n      return token;\n    }\n    let idToken = token;\n    if (idToken instanceof TokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n    const expectedAlg = this.id_token_encrypted_response_alg;\n    const expectedEnc = this.id_token_encrypted_response_enc;\n    const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n    if (token instanceof TokenSet) {\n      token.id_token = result;\n      return token;\n    }\n    return result;\n  }\n  async validateJWTUserinfo(body) {\n    const expectedAlg = this.userinfo_signed_response_alg;\n    return this.validateJWT(body, expectedAlg, []);\n  }\n  async decryptJARM(response) {\n    if (!this.authorization_encrypted_response_alg) {\n      return response;\n    }\n    const expectedAlg = this.authorization_encrypted_response_alg;\n    const expectedEnc = this.authorization_encrypted_response_enc;\n    return this.decryptJWE(response, expectedAlg, expectedEnc);\n  }\n  async decryptJWTUserinfo(body) {\n    if (!this.userinfo_encrypted_response_alg) {\n      return body;\n    }\n    const expectedAlg = this.userinfo_encrypted_response_alg;\n    const expectedEnc = this.userinfo_encrypted_response_enc;\n    return this.decryptJWE(body, expectedAlg, expectedEnc);\n  }\n  async decryptJWE(jwe, expectedAlg) {\n    let expectedEnc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'A128CBC-HS256';\n    const header = JSON.parse(base64url.decode(jwe.split('.')[0]));\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWE alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt: jwe\n      });\n    }\n    if (header.enc !== expectedEnc) {\n      throw new RPError({\n        printf: ['unexpected JWE enc received, expected %s, got: %s', expectedEnc, header.enc],\n        jwt: jwe\n      });\n    }\n    const getPlaintext = result => new TextDecoder().decode(result.plaintext);\n    let plaintext;\n    if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n      const keystore = await keystores.get(this);\n      for (const {\n        keyObject: key\n      } of keystore.all({\n        ...jose.decodeProtectedHeader(jwe),\n        use: 'enc'\n      })) {\n        plaintext = await jose.compactDecrypt(jwe, key).then(getPlaintext, () => {});\n        if (plaintext) break;\n      }\n    } else {\n      plaintext = await jose.compactDecrypt(jwe, this.secretForAlg(expectedAlg === 'dir' ? expectedEnc : expectedAlg)).then(getPlaintext, () => {});\n    }\n    if (!plaintext) {\n      throw new RPError({\n        message: 'failed to decrypt JWE',\n        jwt: jwe\n      });\n    }\n    return plaintext;\n  }\n  async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n    const expectedAlg = this.id_token_signed_response_alg;\n    const isTokenSet = idToken instanceof TokenSet;\n    if (isTokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n    idToken = String(idToken);\n    const timestamp = now();\n    const {\n      protected: header,\n      payload,\n      key\n    } = await this.validateJWT(idToken, expectedAlg);\n    if (typeof maxAge === 'number' || maxAge !== skipMaxAgeCheck && this.require_auth_time) {\n      if (!payload.auth_time) {\n        throw new RPError({\n          message: 'missing required JWT property auth_time',\n          jwt: idToken\n        });\n      }\n      if (typeof payload.auth_time !== 'number') {\n        throw new RPError({\n          message: 'JWT auth_time claim must be a JSON numeric value',\n          jwt: idToken\n        });\n      }\n    }\n    if (typeof maxAge === 'number' && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {\n      throw new RPError({\n        printf: ['too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i', maxAge, payload.auth_time, timestamp - this[CLOCK_TOLERANCE]],\n        now: timestamp,\n        tolerance: this[CLOCK_TOLERANCE],\n        auth_time: payload.auth_time,\n        jwt: idToken\n      });\n    }\n    if (nonce !== skipNonceCheck && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {\n      throw new RPError({\n        printf: ['nonce mismatch, expected %s, got: %s', nonce, payload.nonce],\n        jwt: idToken\n      });\n    }\n    if (returnedBy === 'authorization') {\n      if (!payload.at_hash && tokenSet.access_token) {\n        throw new RPError({\n          message: 'missing required property at_hash',\n          jwt: idToken\n        });\n      }\n      if (!payload.c_hash && tokenSet.code) {\n        throw new RPError({\n          message: 'missing required property c_hash',\n          jwt: idToken\n        });\n      }\n      if (this.fapi()) {\n        if (!payload.s_hash && (tokenSet.state || state)) {\n          throw new RPError({\n            message: 'missing required property s_hash',\n            jwt: idToken\n          });\n        }\n      }\n      if (payload.s_hash) {\n        if (!state) {\n          throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n        }\n        try {\n          tokenHash.validate({\n            claim: 's_hash',\n            source: 'state'\n          }, payload.s_hash, state, header.alg, key.jwk && key.jwk.crv);\n        } catch (err) {\n          throw new RPError({\n            message: err.message,\n            jwt: idToken\n          });\n        }\n      }\n    }\n    if (this.fapi() && payload.iat < timestamp - 3600) {\n      throw new RPError({\n        printf: ['JWT issued too far in the past, now %i, iat %i', timestamp, payload.iat],\n        now: timestamp,\n        tolerance: this[CLOCK_TOLERANCE],\n        iat: payload.iat,\n        jwt: idToken\n      });\n    }\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      try {\n        tokenHash.validate({\n          claim: 'at_hash',\n          source: 'access_token'\n        }, payload.at_hash, tokenSet.access_token, header.alg, key.jwk && key.jwk.crv);\n      } catch (err) {\n        throw new RPError({\n          message: err.message,\n          jwt: idToken\n        });\n      }\n    }\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      try {\n        tokenHash.validate({\n          claim: 'c_hash',\n          source: 'code'\n        }, payload.c_hash, tokenSet.code, header.alg, key.jwk && key.jwk.crv);\n      } catch (err) {\n        throw new RPError({\n          message: err.message,\n          jwt: idToken\n        });\n      }\n    }\n    return tokenSet;\n  }\n  async validateJWT(jwt, expectedAlg) {\n    let required = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['iss', 'sub', 'aud', 'exp', 'iat'];\n    const isSelfIssued = this.issuer.issuer === 'https://self-issued.me';\n    const timestamp = now();\n    let header;\n    let payload;\n    try {\n      ({\n        header,\n        payload\n      } = decodeJWT(jwt, {\n        complete: true\n      }));\n    } catch (err) {\n      throw new RPError({\n        printf: ['failed to decode JWT (%s: %s)', err.name, err.message],\n        jwt\n      });\n    }\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWT alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt\n      });\n    }\n    if (isSelfIssued) {\n      required = [...required, 'sub_jwk'];\n    }\n    required.forEach(verifyPresence.bind(undefined, payload, jwt));\n    if (payload.iss !== undefined) {\n      let expectedIss = this.issuer.issuer;\n      if (this.#aadIssValidation) {\n        expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);\n      }\n      if (payload.iss !== expectedIss) {\n        throw new RPError({\n          printf: ['unexpected iss value, expected %s, got: %s', expectedIss, payload.iss],\n          jwt\n        });\n      }\n    }\n    if (payload.iat !== undefined) {\n      if (typeof payload.iat !== 'number') {\n        throw new RPError({\n          message: 'JWT iat claim must be a JSON numeric value',\n          jwt\n        });\n      }\n    }\n    if (payload.nbf !== undefined) {\n      if (typeof payload.nbf !== 'number') {\n        throw new RPError({\n          message: 'JWT nbf claim must be a JSON numeric value',\n          jwt\n        });\n      }\n      if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n        throw new RPError({\n          printf: ['JWT not active yet, now %i, nbf %i', timestamp + this[CLOCK_TOLERANCE], payload.nbf],\n          now: timestamp,\n          tolerance: this[CLOCK_TOLERANCE],\n          nbf: payload.nbf,\n          jwt\n        });\n      }\n    }\n    if (payload.exp !== undefined) {\n      if (typeof payload.exp !== 'number') {\n        throw new RPError({\n          message: 'JWT exp claim must be a JSON numeric value',\n          jwt\n        });\n      }\n      if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n        throw new RPError({\n          printf: ['JWT expired, now %i, exp %i', timestamp - this[CLOCK_TOLERANCE], payload.exp],\n          now: timestamp,\n          tolerance: this[CLOCK_TOLERANCE],\n          exp: payload.exp,\n          jwt\n        });\n      }\n    }\n    if (payload.aud !== undefined) {\n      if (Array.isArray(payload.aud)) {\n        if (payload.aud.length > 1 && !payload.azp) {\n          throw new RPError({\n            message: 'missing required JWT property azp',\n            jwt\n          });\n        }\n        if (!payload.aud.includes(this.client_id)) {\n          throw new RPError({\n            printf: ['aud is missing the client_id, expected %s to be included in %j', this.client_id, payload.aud],\n            jwt\n          });\n        }\n      } else if (payload.aud !== this.client_id) {\n        throw new RPError({\n          printf: ['aud mismatch, expected %s, got: %s', this.client_id, payload.aud],\n          jwt\n        });\n      }\n    }\n    if (payload.azp !== undefined) {\n      let additionalAuthorizedParties = this.#additionalAuthorizedParties;\n      if (typeof additionalAuthorizedParties === 'string') {\n        additionalAuthorizedParties = [this.client_id, additionalAuthorizedParties];\n      } else if (Array.isArray(additionalAuthorizedParties)) {\n        additionalAuthorizedParties = [this.client_id, ...additionalAuthorizedParties];\n      } else {\n        additionalAuthorizedParties = [this.client_id];\n      }\n      if (!additionalAuthorizedParties.includes(payload.azp)) {\n        throw new RPError({\n          printf: ['azp mismatch, got: %s', payload.azp],\n          jwt\n        });\n      }\n    }\n    let keys;\n    if (isSelfIssued) {\n      try {\n        assert(isPlainObject(payload.sub_jwk));\n        const key = await jose.importJWK(payload.sub_jwk, header.alg);\n        assert.equal(key.type, 'public');\n        keys = [{\n          keyObject: key\n        }];\n      } catch (err) {\n        throw new RPError({\n          message: 'failed to use sub_jwk claim as an asymmetric JSON Web Key',\n          jwt\n        });\n      }\n      if ((await jose.calculateJwkThumbprint(payload.sub_jwk)) !== payload.sub) {\n        throw new RPError({\n          message: 'failed to match the subject with sub_jwk',\n          jwt\n        });\n      }\n    } else if (header.alg.startsWith('HS')) {\n      keys = [this.secretForAlg(header.alg)];\n    } else if (header.alg !== 'none') {\n      keys = await queryKeyStore.call(this.issuer, {\n        ...header,\n        use: 'sig'\n      });\n    }\n    if (!keys && header.alg === 'none') {\n      return {\n        protected: header,\n        payload\n      };\n    }\n    for (const key of keys) {\n      const verified = await jose.compactVerify(jwt, key instanceof Uint8Array ? key : key.keyObject).catch(() => {});\n      if (verified) {\n        return {\n          payload,\n          protected: verified.protectedHeader,\n          key\n        };\n      }\n    }\n    throw new RPError({\n      message: 'failed to validate JWT signature',\n      jwt\n    });\n  }\n  async refresh(refreshToken) {\n    let {\n      exchangeBody,\n      clientAssertionPayload,\n      DPoP\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let token = refreshToken;\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        throw new TypeError('refresh_token not present in TokenSet');\n      }\n      token = token.refresh_token;\n    }\n    const tokenset = await this.grant({\n      ...exchangeBody,\n      grant_type: 'refresh_token',\n      refresh_token: String(token)\n    }, {\n      clientAssertionPayload,\n      DPoP\n    });\n    if (tokenset.id_token) {\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, skipNonceCheck, 'token', skipMaxAgeCheck);\n      if (refreshToken instanceof TokenSet && refreshToken.id_token) {\n        const expectedSub = refreshToken.claims().sub;\n        const actualSub = tokenset.claims().sub;\n        if (actualSub !== expectedSub) {\n          throw new RPError({\n            printf: ['sub mismatch, expected %s, got: %s', expectedSub, actualSub],\n            jwt: tokenset.id_token\n          });\n        }\n      }\n    }\n    return tokenset;\n  }\n  async requestResource(resourceUrl, accessToken) {\n    let {\n      method,\n      headers,\n      body,\n      DPoP,\n      tokenType = DPoP ? 'DPoP' : accessToken instanceof TokenSet ? accessToken.token_type : 'Bearer'\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let retry = arguments.length > 3 ? arguments[3] : undefined;\n    if (accessToken instanceof TokenSet) {\n      if (!accessToken.access_token) {\n        throw new TypeError('access_token not present in TokenSet');\n      }\n      accessToken = accessToken.access_token;\n    }\n    if (!accessToken) {\n      throw new TypeError('no access token provided');\n    } else if (typeof accessToken !== 'string') {\n      throw new TypeError('invalid access token provided');\n    }\n    const requestOpts = {\n      headers: {\n        Authorization: authorizationHeaderValue(accessToken, tokenType),\n        ...headers\n      },\n      body\n    };\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n    const response = await request.call(this, {\n      ...requestOpts,\n      responseType: 'buffer',\n      method,\n      url: resourceUrl\n    }, {\n      accessToken,\n      mTLS,\n      DPoP\n    });\n    const wwwAuthenticate = response.headers['www-authenticate'];\n    if (retry !== retryAttempt && wwwAuthenticate && wwwAuthenticate.toLowerCase().startsWith('dpop ') && parseWwwAuthenticate(wwwAuthenticate).error === 'use_dpop_nonce') {\n      return this.requestResource(resourceUrl, accessToken, {\n        method,\n        headers,\n        body,\n        DPoP,\n        tokenType\n      });\n    }\n    return response;\n  }\n  async userinfo(accessToken) {\n    let {\n      method = 'GET',\n      via = 'header',\n      tokenType,\n      params,\n      DPoP\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');\n    const options = {\n      tokenType,\n      method: String(method).toUpperCase(),\n      DPoP\n    };\n    if (options.method !== 'GET' && options.method !== 'POST') {\n      throw new TypeError('#userinfo() method can only be POST or a GET');\n    }\n    if (via === 'body' && options.method !== 'POST') {\n      throw new TypeError('can only send body on POST');\n    }\n    const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);\n    if (jwt) {\n      options.headers = {\n        Accept: 'application/jwt'\n      };\n    } else {\n      options.headers = {\n        Accept: 'application/json'\n      };\n    }\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n    let targetUrl;\n    if (mTLS && this.issuer.mtls_endpoint_aliases) {\n      targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n    }\n    targetUrl = new url.URL(targetUrl || this.issuer.userinfo_endpoint);\n    if (via === 'body') {\n      options.headers.Authorization = undefined;\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.body = new url.URLSearchParams();\n      options.body.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n    }\n\n    // handle additional parameters, GET via querystring, POST via urlencoded body\n    if (params) {\n      if (options.method === 'GET') {\n        Object.entries(params).forEach(_ref4 => {\n          let [key, value] = _ref4;\n          targetUrl.searchParams.append(key, value);\n        });\n      } else if (options.body) {\n        // POST && via body\n        Object.entries(params).forEach(_ref5 => {\n          let [key, value] = _ref5;\n          options.body.append(key, value);\n        });\n      } else {\n        // POST && via header\n        options.body = new url.URLSearchParams();\n        options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        Object.entries(params).forEach(_ref6 => {\n          let [key, value] = _ref6;\n          options.body.append(key, value);\n        });\n      }\n    }\n    if (options.body) {\n      options.body = options.body.toString();\n    }\n    const response = await this.requestResource(targetUrl, accessToken, options);\n    let parsed = processResponse(response, {\n      bearer: true\n    });\n    if (jwt) {\n      if (!/^application\\/jwt/.test(response.headers['content-type'])) {\n        throw new RPError({\n          message: 'expected application/jwt response from the userinfo_endpoint',\n          response\n        });\n      }\n      const body = response.body.toString();\n      const userinfo = await this.decryptJWTUserinfo(body);\n      if (!this.userinfo_signed_response_alg) {\n        try {\n          parsed = JSON.parse(userinfo);\n          assert(isPlainObject(parsed));\n        } catch (err) {\n          throw new RPError({\n            message: 'failed to parse userinfo JWE payload as JSON',\n            jwt: userinfo\n          });\n        }\n      } else {\n        ({\n          payload: parsed\n        } = await this.validateJWTUserinfo(userinfo));\n      }\n    } else {\n      try {\n        parsed = JSON.parse(response.body);\n      } catch (err) {\n        Object.defineProperty(err, 'response', {\n          value: response\n        });\n        throw err;\n      }\n    }\n    if (accessToken instanceof TokenSet && accessToken.id_token) {\n      const expectedSub = accessToken.claims().sub;\n      if (parsed.sub !== expectedSub) {\n        throw new RPError({\n          printf: ['userinfo sub mismatch, expected %s, got: %s', expectedSub, parsed.sub],\n          body: parsed,\n          jwt: accessToken.id_token\n        });\n      }\n    }\n    return parsed;\n  }\n  encryptionSecret(len) {\n    const hash = len <= 256 ? 'sha256' : len <= 384 ? 'sha384' : len <= 512 ? 'sha512' : false;\n    if (!hash) {\n      throw new Error('unsupported symmetric encryption key derivation');\n    }\n    return crypto.createHash(hash).update(this.client_secret).digest().slice(0, len / 8);\n  }\n  secretForAlg(alg) {\n    if (!this.client_secret) {\n      throw new TypeError('client_secret is required');\n    }\n    if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n      return this.encryptionSecret(parseInt(RegExp.$1, 10));\n    }\n    if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n      return this.encryptionSecret(parseInt(RegExp.$2 || RegExp.$1, 10));\n    }\n    return new TextEncoder().encode(this.client_secret);\n  }\n  async grant(body) {\n    let {\n      clientAssertionPayload,\n      DPoP\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let retry = arguments.length > 2 ? arguments[2] : undefined;\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const response = await authenticatedPost.call(this, 'token', {\n      form: body,\n      responseType: 'json'\n    }, {\n      clientAssertionPayload,\n      DPoP\n    });\n    let responseBody;\n    try {\n      responseBody = processResponse(response);\n    } catch (err) {\n      if (retry !== retryAttempt && err instanceof OPError && err.error === 'use_dpop_nonce') {\n        return this.grant(body, {\n          clientAssertionPayload,\n          DPoP\n        }, retryAttempt);\n      }\n      throw err;\n    }\n    return new TokenSet(responseBody);\n  }\n  async deviceAuthorization() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      exchangeBody,\n      clientAssertionPayload,\n      DPoP\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const body = authorizationParams.call(this, {\n      client_id: this.client_id,\n      redirect_uri: null,\n      response_type: null,\n      ...params\n    });\n    const response = await authenticatedPost.call(this, 'device_authorization', {\n      responseType: 'json',\n      form: body\n    }, {\n      clientAssertionPayload,\n      endpointAuthMethod: 'token'\n    });\n    const responseBody = processResponse(response);\n    return new DeviceFlowHandle({\n      client: this,\n      exchangeBody,\n      clientAssertionPayload,\n      response: responseBody,\n      maxAge: params.max_age,\n      DPoP\n    });\n  }\n  async revoke(token, hint) {\n    let {\n      revokeBody,\n      clientAssertionPayload\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n    const form = {\n      ...revokeBody,\n      token\n    };\n    if (hint) {\n      form.token_type_hint = hint;\n    }\n    const response = await authenticatedPost.call(this, 'revocation', {\n      form\n    }, {\n      clientAssertionPayload\n    });\n    processResponse(response, {\n      body: false\n    });\n  }\n  async introspect(token, hint) {\n    let {\n      introspectBody,\n      clientAssertionPayload\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n    const form = {\n      ...introspectBody,\n      token\n    };\n    if (hint) {\n      form.token_type_hint = hint;\n    }\n    const response = await authenticatedPost.call(this, 'introspection', {\n      form,\n      responseType: 'json'\n    }, {\n      clientAssertionPayload\n    });\n    const responseBody = processResponse(response);\n    return responseBody;\n  }\n  static async register(metadata) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      initialAccessToken,\n      jwks,\n      ...clientOptions\n    } = options;\n    assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n    if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {\n      const keystore = await getKeystore.call(this, jwks);\n      metadata.jwks = keystore.toJWKS();\n    }\n    const response = await request.call(this, {\n      headers: {\n        Accept: 'application/json',\n        ...(initialAccessToken ? {\n          Authorization: authorizationHeaderValue(initialAccessToken)\n        } : undefined)\n      },\n      responseType: 'json',\n      json: metadata,\n      url: this.issuer.registration_endpoint,\n      method: 'POST'\n    });\n    const responseBody = processResponse(response, {\n      statusCode: 201,\n      bearer: true\n    });\n    return new this(responseBody, jwks, clientOptions);\n  }\n  get metadata() {\n    return clone(Object.fromEntries(this.#metadata.entries()));\n  }\n  static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {\n    const response = await request.call(this, {\n      method: 'GET',\n      url: registrationClientUri,\n      responseType: 'json',\n      headers: {\n        Authorization: authorizationHeaderValue(registrationAccessToken),\n        Accept: 'application/json'\n      }\n    });\n    const responseBody = processResponse(response, {\n      bearer: true\n    });\n    return new this(responseBody, jwks, clientOptions);\n  }\n  async requestObject() {\n    let requestObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      sign: signingAlgorithm = this.request_object_signing_alg || 'none',\n      encrypt: {\n        alg: eKeyManagement = this.request_object_encryption_alg,\n        enc: eContentEncryption = this.request_object_encryption_enc || 'A128CBC-HS256'\n      } = {}\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isPlainObject(requestObject)) {\n      throw new TypeError('requestObject must be a plain object');\n    }\n    let signed;\n    let key;\n    const unix = now();\n    const header = {\n      alg: signingAlgorithm,\n      typ: 'oauth-authz-req+jwt'\n    };\n    const payload = JSON.stringify(defaults({}, requestObject, {\n      iss: this.client_id,\n      aud: this.issuer.issuer,\n      client_id: this.client_id,\n      jti: random(),\n      iat: unix,\n      exp: unix + 300,\n      ...(this.fapi() ? {\n        nbf: unix\n      } : undefined)\n    }));\n    if (signingAlgorithm === 'none') {\n      signed = [base64url.encode(JSON.stringify(header)), base64url.encode(payload), ''].join('.');\n    } else {\n      const symmetric = signingAlgorithm.startsWith('HS');\n      if (symmetric) {\n        key = this.secretForAlg(signingAlgorithm);\n      } else {\n        const keystore = await keystores.get(this);\n        if (!keystore) {\n          throw new TypeError(`no keystore present for client, cannot sign using alg ${signingAlgorithm}`);\n        }\n        key = keystore.get({\n          alg: signingAlgorithm,\n          use: 'sig'\n        });\n        if (!key) {\n          throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);\n        }\n      }\n      signed = await new jose.CompactSign(new TextEncoder().encode(payload)).setProtectedHeader({\n        ...header,\n        kid: symmetric ? undefined : key.jwk.kid\n      }).sign(symmetric ? key : key.keyObject);\n    }\n    if (!eKeyManagement) {\n      return signed;\n    }\n    const fields = {\n      alg: eKeyManagement,\n      enc: eContentEncryption,\n      cty: 'oauth-authz-req+jwt'\n    };\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      [key] = await queryKeyStore.call(this.issuer, {\n        alg: fields.alg,\n        use: 'enc'\n      }, {\n        allowMulti: true\n      });\n    } else {\n      key = this.secretForAlg(fields.alg === 'dir' ? fields.enc : fields.alg);\n    }\n    return new jose.CompactEncrypt(new TextEncoder().encode(signed)).setProtectedHeader({\n      ...fields,\n      kid: key instanceof Uint8Array ? undefined : key.jwk.kid\n    }).encrypt(key instanceof Uint8Array ? key : key.keyObject);\n  }\n  async pushedAuthorizationRequest() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      clientAssertionPayload\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assertIssuerConfiguration(this.issuer, 'pushed_authorization_request_endpoint');\n    const body = {\n      ...('request' in params ? params : authorizationParams.call(this, params)),\n      client_id: this.client_id\n    };\n    const response = await authenticatedPost.call(this, 'pushed_authorization_request', {\n      responseType: 'json',\n      form: body\n    }, {\n      clientAssertionPayload,\n      endpointAuthMethod: 'token'\n    });\n    const responseBody = processResponse(response, {\n      statusCode: 201\n    });\n    if (!('expires_in' in responseBody)) {\n      throw new RPError({\n        message: 'expected expires_in in Pushed Authorization Successful Response',\n        response\n      });\n    }\n    if (typeof responseBody.expires_in !== 'number') {\n      throw new RPError({\n        message: 'invalid expires_in value in Pushed Authorization Successful Response',\n        response\n      });\n    }\n    if (!('request_uri' in responseBody)) {\n      throw new RPError({\n        message: 'expected request_uri in Pushed Authorization Successful Response',\n        response\n      });\n    }\n    if (typeof responseBody.request_uri !== 'string') {\n      throw new RPError({\n        message: 'invalid request_uri value in Pushed Authorization Successful Response',\n        response\n      });\n    }\n    return responseBody;\n  }\n  get issuer() {\n    return this.#issuer;\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    })}`;\n  }\n  fapi() {\n    return this.constructor.name === 'FAPI1Client';\n  }\n  async validateJARM(response) {\n    const expectedAlg = this.authorization_signed_response_alg;\n    const {\n      payload\n    } = await this.validateJWT(response, expectedAlg, ['iss', 'exp', 'aud']);\n    return pickCb(payload);\n  }\n}\nconst RSPS = /^(?:RS|PS)(?:256|384|512)$/;\nfunction determineRsaAlgorithm(privateKey, privateKeyInput, valuesSupported) {\n  if (typeof privateKeyInput === 'object' && typeof privateKeyInput.key === 'object' && privateKeyInput.key.alg) {\n    return privateKeyInput.key.alg;\n  }\n  if (Array.isArray(valuesSupported)) {\n    let candidates = valuesSupported.filter(RegExp.prototype.test.bind(RSPS));\n    if (privateKey.asymmetricKeyType === 'rsa-pss') {\n      candidates = candidates.filter(value => value.startsWith('PS'));\n    }\n    return ['PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS384'].find(preferred => candidates.includes(preferred));\n  }\n  return 'PS256';\n}\nconst p256 = Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);\nconst p384 = Buffer.from([43, 129, 4, 0, 34]);\nconst p521 = Buffer.from([43, 129, 4, 0, 35]);\nconst secp256k1 = Buffer.from([43, 129, 4, 0, 10]);\nfunction determineEcAlgorithm(privateKey, privateKeyInput) {\n  // If input was a JWK\n  switch (typeof privateKeyInput === 'object' && typeof privateKeyInput.key === 'object' && privateKeyInput.key.crv) {\n    case 'P-256':\n      return 'ES256';\n    case 'secp256k1':\n      return 'ES256K';\n    case 'P-384':\n      return 'ES384';\n    case 'P-512':\n      return 'ES512';\n    default:\n      break;\n  }\n  const buf = privateKey.export({\n    format: 'der',\n    type: 'pkcs8'\n  });\n  const i = buf[1] < 128 ? 17 : 18;\n  const len = buf[i];\n  const curveOid = buf.slice(i + 1, i + 1 + len);\n  if (curveOid.equals(p256)) {\n    return 'ES256';\n  }\n  if (curveOid.equals(p384)) {\n    return 'ES384';\n  }\n  if (curveOid.equals(p521)) {\n    return 'ES512';\n  }\n  if (curveOid.equals(secp256k1)) {\n    return 'ES256K';\n  }\n  throw new TypeError('unsupported DPoP private key curve');\n}\nconst jwkCache = new WeakMap();\nasync function getJwk(privateKey, privateKeyInput) {\n  if (typeof privateKeyInput === 'object' && typeof privateKeyInput.key === 'object' && privateKeyInput.key.crv) {\n    return pick(privateKeyInput.key, 'kty', 'crv', 'x', 'y', 'e', 'n');\n  }\n  if (jwkCache.has(privateKeyInput)) {\n    return jwkCache.get(privateKeyInput);\n  }\n  const jwk = pick(await jose.exportJWK(privateKey), 'kty', 'crv', 'x', 'y', 'e', 'n');\n  if (isKeyObject(privateKeyInput)) {\n    jwkCache.set(privateKeyInput, jwk);\n  }\n  return jwk;\n}\n\n/**\n * @name dpopProof\n * @api private\n */\nasync function dpopProof(payload, privateKeyInput, accessToken) {\n  if (!isPlainObject(payload)) {\n    throw new TypeError('payload must be a plain object');\n  }\n  let privateKey;\n  if (isKeyObject(privateKeyInput)) {\n    privateKey = privateKeyInput;\n  } else {\n    privateKey = crypto.createPrivateKey(privateKeyInput);\n  }\n  if (privateKey.type !== 'private') {\n    throw new TypeError('\"DPoP\" option must be a private key');\n  }\n  let alg;\n  switch (privateKey.asymmetricKeyType) {\n    case 'ed25519':\n    case 'ed448':\n      alg = 'EdDSA';\n      break;\n    case 'ec':\n      alg = determineEcAlgorithm(privateKey, privateKeyInput);\n      break;\n    case 'rsa':\n    case rsaPssParams && 'rsa-pss':\n      alg = determineRsaAlgorithm(privateKey, privateKeyInput, this.issuer.dpop_signing_alg_values_supported);\n      break;\n    default:\n      throw new TypeError('unsupported DPoP private key asymmetric key type');\n  }\n  if (!alg) {\n    throw new TypeError('could not determine DPoP JWS Algorithm');\n  }\n  return new jose.SignJWT({\n    ath: accessToken ? base64url.encode(crypto.createHash('sha256').update(accessToken).digest()) : undefined,\n    ...payload\n  }).setProtectedHeader({\n    alg,\n    typ: 'dpop+jwt',\n    jwk: await getJwk(privateKey, privateKeyInput)\n  }).setIssuedAt().setJti(random()).sign(privateKey);\n}\nObject.defineProperty(BaseClient.prototype, 'dpopProof', {\n  enumerable: true,\n  configurable: true,\n  value() {\n    process.emitWarning('The DPoP APIs implements an IETF draft (https://www.ietf.org/archive/id/draft-ietf-oauth-dpop-04.html). Breaking draft implementations are included as minor versions of the openid-client library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.', 'DraftWarning');\n    Object.defineProperty(BaseClient.prototype, 'dpopProof', {\n      enumerable: true,\n      configurable: true,\n      value: dpopProof\n    });\n    return this.dpopProof(...arguments);\n  }\n});\nmodule.exports = function (issuer) {\n  let aadIssValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return class Client extends BaseClient {\n    constructor() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      super(issuer, aadIssValidation, ...args);\n    }\n    static get issuer() {\n      return issuer;\n    }\n  };\n};\nmodule.exports.BaseClient = BaseClient;","map":{"version":3,"names":["inspect","require","stdhttp","crypto","strict","assert","querystring","url","jose","tokenHash","isKeyObject","decodeJWT","base64url","defaults","parseWwwAuthenticate","assertSigningAlgValuesSupport","assertIssuerConfiguration","pick","isPlainObject","processResponse","TokenSet","OPError","RPError","now","random","request","CLOCK_TOLERANCE","keystores","KeyStore","clone","authenticatedPost","resolveResponseType","resolveRedirectUri","queryKeyStore","DeviceFlowHandle","major","minor","process","version","slice","split","map","str","parseInt","rsaPssParams","retryAttempt","Symbol","skipNonceCheck","skipMaxAgeCheck","pickCb","input","authorizationHeaderValue","token","tokenType","verifyPresence","payload","jwt","prop","undefined","message","authorizationParams","params","authParams","client_id","scope","response_type","call","redirect_uri","Object","entries","forEach","key","value","JSON","stringify","Array","isArray","String","getKeystore","jwks","keys","some","k","TypeError","fromJWKS","onlyPrivate","checkBasicSupport","client","properties","supported","issuer","token_endpoint_auth_methods_supported","includes","token_endpoint_auth_method","err","handleCommonMistakes","metadata","redirect_uris","response_types","getDefaultsForEndpoint","endpoint","tokenEndpointAuthMethod","tokenEndpointAuthSigningAlg","token_endpoint_auth_signing_alg","eam","easa","BaseClient","aadIssValidation","additionalAuthorizedParties","constructor","options","Map","grant_types","id_token_signed_response_alg","authorization_signed_response_alg","fapi","tls_client_certificate_bound_access_tokens","set","defineProperty","get","enumerable","keystore","authorizationUrl","target","parse","authorization_endpoint","search","query","format","authorizationPost","inputs","formInputs","name","join","endSessionUrl","postLogout","length","post_logout_redirect_uris","post_logout_redirect_uri","id_token_hint","id_token","end_session_endpoint","callbackParams","isIncomingMessage","IncomingMessage","method","isString","body","Buffer","isBuffer","toString","callback","redirectUri","parameters","checks","exchangeBody","clientAssertionPayload","DPoP","jarm","decrypted","decryptJARM","response","validateJARM","default_max_age","max_age","state","printf","iss","authorization_response_iss_parameter_supported","error","RESPONSE_TYPE_REQUIRED_PARAMS","code","type","access_token","param","tokenset","decryptIdToken","validateIdToken","nonce","grant","grant_type","code_verifier","session_state","oauthCallback","id_token_encrypted_response_alg","idToken","expectedAlg","expectedEnc","id_token_encrypted_response_enc","result","decryptJWE","validateJWTUserinfo","userinfo_signed_response_alg","validateJWT","authorization_encrypted_response_alg","authorization_encrypted_response_enc","decryptJWTUserinfo","userinfo_encrypted_response_alg","userinfo_encrypted_response_enc","jwe","header","decode","alg","enc","getPlaintext","TextDecoder","plaintext","match","keyObject","all","decodeProtectedHeader","use","compactDecrypt","then","secretForAlg","tokenSet","returnedBy","maxAge","isTokenSet","timestamp","protected","require_auth_time","auth_time","tolerance","at_hash","c_hash","s_hash","validate","claim","source","jwk","crv","iat","required","isSelfIssued","complete","bind","expectedIss","replace","tid","nbf","exp","aud","azp","sub_jwk","importJWK","equal","calculateJwkThumbprint","sub","startsWith","verified","compactVerify","Uint8Array","catch","protectedHeader","refresh","refreshToken","refresh_token","expectedSub","claims","actualSub","requestResource","resourceUrl","accessToken","headers","token_type","retry","requestOpts","Authorization","mTLS","responseType","wwwAuthenticate","toLowerCase","userinfo","via","toUpperCase","Accept","targetUrl","mtls_endpoint_aliases","userinfo_endpoint","URL","URLSearchParams","append","searchParams","parsed","bearer","test","encryptionSecret","len","hash","Error","createHash","update","client_secret","digest","RegExp","$1","$2","TextEncoder","encode","form","responseBody","deviceAuthorization","endpointAuthMethod","revoke","hint","revokeBody","token_type_hint","introspect","introspectBody","register","initialAccessToken","clientOptions","jwks_uri","toJWKS","json","registration_endpoint","statusCode","fromEntries","fromUri","registrationClientUri","registrationAccessToken","requestObject","sign","signingAlgorithm","request_object_signing_alg","encrypt","eKeyManagement","request_object_encryption_alg","eContentEncryption","request_object_encryption_enc","signed","unix","typ","jti","symmetric","CompactSign","setProtectedHeader","kid","fields","cty","allowMulti","CompactEncrypt","pushedAuthorizationRequest","expires_in","request_uri","custom","depth","Infinity","colors","stdout","isTTY","compact","sorted","RSPS","determineRsaAlgorithm","privateKey","privateKeyInput","valuesSupported","candidates","filter","prototype","asymmetricKeyType","find","preferred","p256","from","p384","p521","secp256k1","determineEcAlgorithm","buf","export","i","curveOid","equals","jwkCache","WeakMap","getJwk","has","exportJWK","dpopProof","createPrivateKey","dpop_signing_alg_values_supported","SignJWT","ath","setIssuedAt","setJti","configurable","emitWarning","module","exports","Client","args"],"sources":["C:/Users/yuleg/Dev/Ringca/ORIN33/ringcard/ringcard_frontend/node_modules/openid-client/lib/client.js"],"sourcesContent":["const { inspect } = require('util');\nconst stdhttp = require('http');\nconst crypto = require('crypto');\nconst { strict: assert } = require('assert');\nconst querystring = require('querystring');\nconst url = require('url');\n\nconst jose = require('jose');\nconst tokenHash = require('oidc-token-hash');\n\nconst isKeyObject = require('./helpers/is_key_object');\nconst decodeJWT = require('./helpers/decode_jwt');\nconst base64url = require('./helpers/base64url');\nconst defaults = require('./helpers/defaults');\nconst parseWwwAuthenticate = require('./helpers/www_authenticate_parser');\nconst { assertSigningAlgValuesSupport, assertIssuerConfiguration } = require('./helpers/assert');\nconst pick = require('./helpers/pick');\nconst isPlainObject = require('./helpers/is_plain_object');\nconst processResponse = require('./helpers/process_response');\nconst TokenSet = require('./token_set');\nconst { OPError, RPError } = require('./errors');\nconst now = require('./helpers/unix_timestamp');\nconst { random } = require('./helpers/generators');\nconst request = require('./helpers/request');\nconst { CLOCK_TOLERANCE } = require('./helpers/consts');\nconst { keystores } = require('./helpers/weak_cache');\nconst KeyStore = require('./helpers/keystore');\nconst clone = require('./helpers/deep_clone');\nconst { authenticatedPost, resolveResponseType, resolveRedirectUri } = require('./helpers/client');\nconst { queryKeyStore } = require('./helpers/issuer');\nconst DeviceFlowHandle = require('./device_flow_handle');\n\nconst [major, minor] = process.version\n  .slice(1)\n  .split('.')\n  .map((str) => parseInt(str, 10));\n\nconst rsaPssParams = major >= 17 || (major === 16 && minor >= 9);\nconst retryAttempt = Symbol();\nconst skipNonceCheck = Symbol();\nconst skipMaxAgeCheck = Symbol();\n\nfunction pickCb(input) {\n  return pick(\n    input,\n    'access_token', // OAuth 2.0\n    'code', // OAuth 2.0\n    'error_description', // OAuth 2.0\n    'error_uri', // OAuth 2.0\n    'error', // OAuth 2.0\n    'expires_in', // OAuth 2.0\n    'id_token', // OIDC Core 1.0\n    'iss', // draft-ietf-oauth-iss-auth-resp\n    'response', // FAPI JARM\n    'session_state', // OIDC Session Management\n    'state', // OAuth 2.0\n    'token_type', // OAuth 2.0\n  );\n}\n\nfunction authorizationHeaderValue(token, tokenType = 'Bearer') {\n  return `${tokenType} ${token}`;\n}\n\nfunction verifyPresence(payload, jwt, prop) {\n  if (payload[prop] === undefined) {\n    throw new RPError({\n      message: `missing required JWT property ${prop}`,\n      jwt,\n    });\n  }\n}\n\nfunction authorizationParams(params) {\n  const authParams = {\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: resolveResponseType.call(this),\n    redirect_uri: resolveRedirectUri.call(this),\n    ...params,\n  };\n\n  Object.entries(authParams).forEach(([key, value]) => {\n    if (value === null || value === undefined) {\n      delete authParams[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      authParams[key] = JSON.stringify(value);\n    } else if (key === 'resource' && Array.isArray(value)) {\n      authParams[key] = value;\n    } else if (typeof value !== 'string') {\n      authParams[key] = String(value);\n    }\n  });\n\n  return authParams;\n}\n\nfunction getKeystore(jwks) {\n  if (\n    !isPlainObject(jwks) ||\n    !Array.isArray(jwks.keys) ||\n    jwks.keys.some((k) => !isPlainObject(k) || !('kty' in k))\n  ) {\n    throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n  }\n\n  return KeyStore.fromJWKS(jwks, { onlyPrivate: true });\n}\n\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\n\nfunction handleCommonMistakes(client, metadata, properties) {\n  if (!metadata.token_endpoint_auth_method) {\n    // if no explicit value was provided\n    checkBasicSupport(client, properties);\n  }\n\n  // :fp: c'mon people... RTFM\n  if (metadata.redirect_uri) {\n    if (metadata.redirect_uris) {\n      throw new TypeError('provide a redirect_uri or redirect_uris, not both');\n    }\n    properties.redirect_uris = [metadata.redirect_uri];\n    delete properties.redirect_uri;\n  }\n\n  if (metadata.response_type) {\n    if (metadata.response_types) {\n      throw new TypeError('provide a response_type or response_types, not both');\n    }\n    properties.response_types = [metadata.response_type];\n    delete properties.response_type;\n  }\n}\n\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n\n  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n\n  if (properties[eam] === undefined && properties[easa] === undefined) {\n    if (tokenEndpointAuthMethod !== undefined) {\n      properties[eam] = tokenEndpointAuthMethod;\n    }\n    if (tokenEndpointAuthSigningAlg !== undefined) {\n      properties[easa] = tokenEndpointAuthSigningAlg;\n    }\n  }\n}\n\nclass BaseClient {\n  #metadata;\n  #issuer;\n  #aadIssValidation;\n  #additionalAuthorizedParties;\n  constructor(issuer, aadIssValidation, metadata = {}, jwks, options) {\n    this.#metadata = new Map();\n    this.#issuer = issuer;\n    this.#aadIssValidation = aadIssValidation;\n\n    if (typeof metadata.client_id !== 'string' || !metadata.client_id) {\n      throw new TypeError('client_id is required');\n    }\n\n    const properties = {\n      grant_types: ['authorization_code'],\n      id_token_signed_response_alg: 'RS256',\n      authorization_signed_response_alg: 'RS256',\n      response_types: ['code'],\n      token_endpoint_auth_method: 'client_secret_basic',\n      ...(this.fapi()\n        ? {\n            grant_types: ['authorization_code', 'implicit'],\n            id_token_signed_response_alg: 'PS256',\n            authorization_signed_response_alg: 'PS256',\n            response_types: ['code id_token'],\n            tls_client_certificate_bound_access_tokens: true,\n            token_endpoint_auth_method: undefined,\n          }\n        : undefined),\n      ...metadata,\n    };\n\n    if (this.fapi()) {\n      switch (properties.token_endpoint_auth_method) {\n        case 'self_signed_tls_client_auth':\n        case 'tls_client_auth':\n          break;\n        case 'private_key_jwt':\n          if (!jwks) {\n            throw new TypeError('jwks is required');\n          }\n          break;\n        case undefined:\n          throw new TypeError('token_endpoint_auth_method is required');\n        default:\n          throw new TypeError('invalid or unsupported token_endpoint_auth_method');\n      }\n    }\n\n    handleCommonMistakes(this, metadata, properties);\n\n    assertSigningAlgValuesSupport('token', this.issuer, properties);\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      getDefaultsForEndpoint(endpoint, this.issuer, properties);\n      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n    });\n\n    Object.entries(properties).forEach(([key, value]) => {\n      this.#metadata.set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return this.#metadata.get(key);\n          },\n          enumerable: true,\n        });\n      }\n    });\n\n    if (jwks !== undefined) {\n      const keystore = getKeystore.call(this, jwks);\n      keystores.set(this, keystore);\n    }\n\n    if (options != null && options.additionalAuthorizedParties) {\n      this.#additionalAuthorizedParties = clone(options.additionalAuthorizedParties);\n    }\n\n    this[CLOCK_TOLERANCE] = 0;\n  }\n\n  authorizationUrl(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    target.query = {\n      ...target.query,\n      ...authorizationParams.call(this, params),\n    };\n    return url.format(target);\n  }\n\n  authorizationPost(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs)\n      .map((name) => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`)\n      .join('\\n');\n\n    return `<!DOCTYPE html>\n<head>\n<title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n<form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n  ${formInputs}\n</form>\n</body>\n</html>`;\n  }\n\n  endSessionUrl(params = {}) {\n    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n\n    const { 0: postLogout, length } = this.post_logout_redirect_uris || [];\n\n    const { post_logout_redirect_uri = length === 1 ? postLogout : undefined } = params;\n\n    let id_token_hint;\n    ({ id_token_hint, ...params } = params);\n    if (id_token_hint instanceof TokenSet) {\n      if (!id_token_hint.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      id_token_hint = id_token_hint.id_token;\n    }\n\n    const target = url.parse(this.issuer.end_session_endpoint, true);\n    target.search = null;\n    defaults(\n      target.query,\n      params,\n      {\n        post_logout_redirect_uri,\n        client_id: this.client_id,\n      },\n      { id_token_hint },\n    );\n\n    Object.entries(target.query).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        delete target.query[key];\n      }\n    });\n\n    return url.format(target);\n  }\n\n  callbackParams(input) {\n    const isIncomingMessage =\n      input instanceof stdhttp.IncomingMessage || (input && input.method && input.url);\n    const isString = typeof input === 'string';\n\n    if (!isString && !isIncomingMessage) {\n      throw new TypeError(\n        '#callbackParams only accepts string urls, http.IncomingMessage or a lookalike',\n      );\n    }\n    if (isIncomingMessage) {\n      switch (input.method) {\n        case 'GET':\n          return pickCb(url.parse(input.url, true).query);\n        case 'POST':\n          if (input.body === undefined) {\n            throw new TypeError(\n              'incoming message body missing, include a body parser prior to this method call',\n            );\n          }\n          switch (typeof input.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(input.body)) {\n                return pickCb(querystring.parse(input.body.toString('utf-8')));\n              }\n              if (typeof input.body === 'string') {\n                return pickCb(querystring.parse(input.body));\n              }\n\n              return pickCb(input.body);\n            default:\n              throw new TypeError('invalid IncomingMessage body object');\n          }\n        default:\n          throw new TypeError('invalid IncomingMessage method');\n      }\n    } else {\n      return pickCb(url.parse(input, true).query);\n    }\n  }\n\n  async callback(\n    redirectUri,\n    parameters,\n    checks = {},\n    { exchangeBody, clientAssertionPayload, DPoP } = {},\n  ) {\n    let params = pickCb(parameters);\n\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params,\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n\n    if (this.default_max_age && !checks.max_age) {\n      checks.max_age = this.default_max_age;\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params,\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params,\n      });\n    }\n\n    if ('iss' in params) {\n      assertIssuerConfiguration(this.issuer, 'issuer');\n      if (params.iss !== this.issuer.issuer) {\n        throw new RPError({\n          printf: ['iss mismatch, expected %s, got: %s', this.issuer.issuer, params.iss],\n          params,\n        });\n      }\n    } else if (\n      this.issuer.authorization_response_iss_parameter_supported &&\n      !('id_token' in params) &&\n      !('response' in parameters)\n    ) {\n      throw new RPError({\n        message: 'iss missing from the response',\n        params,\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      id_token: ['id_token'],\n      token: ['access_token', 'token_type'],\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params,\n            });\n          }\n        } else {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.id_token) {\n      const tokenset = new TokenSet(params);\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(\n        tokenset,\n        checks.nonce,\n        'authorization',\n        checks.max_age,\n        checks.state,\n      );\n\n      if (!params.code) {\n        return tokenset;\n      }\n    }\n\n    if (params.code) {\n      const tokenset = await this.grant(\n        {\n          ...exchangeBody,\n          grant_type: 'authorization_code',\n          code: params.code,\n          redirect_uri: redirectUri,\n          code_verifier: checks.code_verifier,\n        },\n        { clientAssertionPayload, DPoP },\n      );\n\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);\n\n      if (params.session_state) {\n        tokenset.session_state = params.session_state;\n      }\n\n      return tokenset;\n    }\n\n    return new TokenSet(params);\n  }\n\n  async oauthCallback(\n    redirectUri,\n    parameters,\n    checks = {},\n    { exchangeBody, clientAssertionPayload, DPoP } = {},\n  ) {\n    let params = pickCb(parameters);\n\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params,\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params,\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params,\n      });\n    }\n\n    if ('iss' in params) {\n      assertIssuerConfiguration(this.issuer, 'issuer');\n      if (params.iss !== this.issuer.issuer) {\n        throw new RPError({\n          printf: ['iss mismatch, expected %s, got: %s', this.issuer.issuer, params.iss],\n          params,\n        });\n      }\n    } else if (\n      this.issuer.authorization_response_iss_parameter_supported &&\n      !('id_token' in params) &&\n      !('response' in parameters)\n    ) {\n      throw new RPError({\n        message: 'iss missing from the response',\n        params,\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    if (typeof params.id_token === 'string' && params.id_token.length) {\n      throw new RPError({\n        message:\n          'id_token detected in the response, you must use client.callback() instead of client.oauthCallback()',\n        params,\n      });\n    }\n    delete params.id_token;\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      token: ['access_token', 'token_type'],\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params,\n            });\n          }\n        }\n\n        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.code) {\n      const tokenset = await this.grant(\n        {\n          ...exchangeBody,\n          grant_type: 'authorization_code',\n          code: params.code,\n          redirect_uri: redirectUri,\n          code_verifier: checks.code_verifier,\n        },\n        { clientAssertionPayload, DPoP },\n      );\n\n      if (typeof tokenset.id_token === 'string' && tokenset.id_token.length) {\n        throw new RPError({\n          message:\n            'id_token detected in the response, you must use client.callback() instead of client.oauthCallback()',\n          params,\n        });\n      }\n      delete tokenset.id_token;\n\n      return tokenset;\n    }\n\n    return new TokenSet(params);\n  }\n\n  async decryptIdToken(token) {\n    if (!this.id_token_encrypted_response_alg) {\n      return token;\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n\n    const expectedAlg = this.id_token_encrypted_response_alg;\n    const expectedEnc = this.id_token_encrypted_response_enc;\n\n    const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n\n    if (token instanceof TokenSet) {\n      token.id_token = result;\n      return token;\n    }\n\n    return result;\n  }\n\n  async validateJWTUserinfo(body) {\n    const expectedAlg = this.userinfo_signed_response_alg;\n\n    return this.validateJWT(body, expectedAlg, []);\n  }\n\n  async decryptJARM(response) {\n    if (!this.authorization_encrypted_response_alg) {\n      return response;\n    }\n\n    const expectedAlg = this.authorization_encrypted_response_alg;\n    const expectedEnc = this.authorization_encrypted_response_enc;\n\n    return this.decryptJWE(response, expectedAlg, expectedEnc);\n  }\n\n  async decryptJWTUserinfo(body) {\n    if (!this.userinfo_encrypted_response_alg) {\n      return body;\n    }\n\n    const expectedAlg = this.userinfo_encrypted_response_alg;\n    const expectedEnc = this.userinfo_encrypted_response_enc;\n\n    return this.decryptJWE(body, expectedAlg, expectedEnc);\n  }\n\n  async decryptJWE(jwe, expectedAlg, expectedEnc = 'A128CBC-HS256') {\n    const header = JSON.parse(base64url.decode(jwe.split('.')[0]));\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWE alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt: jwe,\n      });\n    }\n\n    if (header.enc !== expectedEnc) {\n      throw new RPError({\n        printf: ['unexpected JWE enc received, expected %s, got: %s', expectedEnc, header.enc],\n        jwt: jwe,\n      });\n    }\n\n    const getPlaintext = (result) => new TextDecoder().decode(result.plaintext);\n    let plaintext;\n    if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n      const keystore = await keystores.get(this);\n\n      for (const { keyObject: key } of keystore.all({\n        ...jose.decodeProtectedHeader(jwe),\n        use: 'enc',\n      })) {\n        plaintext = await jose.compactDecrypt(jwe, key).then(getPlaintext, () => {});\n        if (plaintext) break;\n      }\n    } else {\n      plaintext = await jose\n        .compactDecrypt(jwe, this.secretForAlg(expectedAlg === 'dir' ? expectedEnc : expectedAlg))\n        .then(getPlaintext, () => {});\n    }\n\n    if (!plaintext) {\n      throw new RPError({\n        message: 'failed to decrypt JWE',\n        jwt: jwe,\n      });\n    }\n    return plaintext;\n  }\n\n  async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n\n    const expectedAlg = this.id_token_signed_response_alg;\n\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n\n    const timestamp = now();\n    const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);\n\n    if (typeof maxAge === 'number' || (maxAge !== skipMaxAgeCheck && this.require_auth_time)) {\n      if (!payload.auth_time) {\n        throw new RPError({\n          message: 'missing required JWT property auth_time',\n          jwt: idToken,\n        });\n      }\n      if (typeof payload.auth_time !== 'number') {\n        throw new RPError({\n          message: 'JWT auth_time claim must be a JSON numeric value',\n          jwt: idToken,\n        });\n      }\n    }\n\n    if (\n      typeof maxAge === 'number' &&\n      payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]\n    ) {\n      throw new RPError({\n        printf: [\n          'too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i',\n          maxAge,\n          payload.auth_time,\n          timestamp - this[CLOCK_TOLERANCE],\n        ],\n        now: timestamp,\n        tolerance: this[CLOCK_TOLERANCE],\n        auth_time: payload.auth_time,\n        jwt: idToken,\n      });\n    }\n\n    if (\n      nonce !== skipNonceCheck &&\n      (payload.nonce || nonce !== undefined) &&\n      payload.nonce !== nonce\n    ) {\n      throw new RPError({\n        printf: ['nonce mismatch, expected %s, got: %s', nonce, payload.nonce],\n        jwt: idToken,\n      });\n    }\n\n    if (returnedBy === 'authorization') {\n      if (!payload.at_hash && tokenSet.access_token) {\n        throw new RPError({\n          message: 'missing required property at_hash',\n          jwt: idToken,\n        });\n      }\n\n      if (!payload.c_hash && tokenSet.code) {\n        throw new RPError({\n          message: 'missing required property c_hash',\n          jwt: idToken,\n        });\n      }\n\n      if (this.fapi()) {\n        if (!payload.s_hash && (tokenSet.state || state)) {\n          throw new RPError({\n            message: 'missing required property s_hash',\n            jwt: idToken,\n          });\n        }\n      }\n\n      if (payload.s_hash) {\n        if (!state) {\n          throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n        }\n\n        try {\n          tokenHash.validate(\n            { claim: 's_hash', source: 'state' },\n            payload.s_hash,\n            state,\n            header.alg,\n            key.jwk && key.jwk.crv,\n          );\n        } catch (err) {\n          throw new RPError({ message: err.message, jwt: idToken });\n        }\n      }\n    }\n\n    if (this.fapi() && payload.iat < timestamp - 3600) {\n      throw new RPError({\n        printf: ['JWT issued too far in the past, now %i, iat %i', timestamp, payload.iat],\n        now: timestamp,\n        tolerance: this[CLOCK_TOLERANCE],\n        iat: payload.iat,\n        jwt: idToken,\n      });\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      try {\n        tokenHash.validate(\n          { claim: 'at_hash', source: 'access_token' },\n          payload.at_hash,\n          tokenSet.access_token,\n          header.alg,\n          key.jwk && key.jwk.crv,\n        );\n      } catch (err) {\n        throw new RPError({ message: err.message, jwt: idToken });\n      }\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      try {\n        tokenHash.validate(\n          { claim: 'c_hash', source: 'code' },\n          payload.c_hash,\n          tokenSet.code,\n          header.alg,\n          key.jwk && key.jwk.crv,\n        );\n      } catch (err) {\n        throw new RPError({ message: err.message, jwt: idToken });\n      }\n    }\n\n    return tokenSet;\n  }\n\n  async validateJWT(jwt, expectedAlg, required = ['iss', 'sub', 'aud', 'exp', 'iat']) {\n    const isSelfIssued = this.issuer.issuer === 'https://self-issued.me';\n    const timestamp = now();\n    let header;\n    let payload;\n    try {\n      ({ header, payload } = decodeJWT(jwt, { complete: true }));\n    } catch (err) {\n      throw new RPError({\n        printf: ['failed to decode JWT (%s: %s)', err.name, err.message],\n        jwt,\n      });\n    }\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWT alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt,\n      });\n    }\n\n    if (isSelfIssued) {\n      required = [...required, 'sub_jwk'];\n    }\n\n    required.forEach(verifyPresence.bind(undefined, payload, jwt));\n\n    if (payload.iss !== undefined) {\n      let expectedIss = this.issuer.issuer;\n\n      if (this.#aadIssValidation) {\n        expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);\n      }\n\n      if (payload.iss !== expectedIss) {\n        throw new RPError({\n          printf: ['unexpected iss value, expected %s, got: %s', expectedIss, payload.iss],\n          jwt,\n        });\n      }\n    }\n\n    if (payload.iat !== undefined) {\n      if (typeof payload.iat !== 'number') {\n        throw new RPError({\n          message: 'JWT iat claim must be a JSON numeric value',\n          jwt,\n        });\n      }\n    }\n\n    if (payload.nbf !== undefined) {\n      if (typeof payload.nbf !== 'number') {\n        throw new RPError({\n          message: 'JWT nbf claim must be a JSON numeric value',\n          jwt,\n        });\n      }\n      if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n        throw new RPError({\n          printf: [\n            'JWT not active yet, now %i, nbf %i',\n            timestamp + this[CLOCK_TOLERANCE],\n            payload.nbf,\n          ],\n          now: timestamp,\n          tolerance: this[CLOCK_TOLERANCE],\n          nbf: payload.nbf,\n          jwt,\n        });\n      }\n    }\n\n    if (payload.exp !== undefined) {\n      if (typeof payload.exp !== 'number') {\n        throw new RPError({\n          message: 'JWT exp claim must be a JSON numeric value',\n          jwt,\n        });\n      }\n      if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n        throw new RPError({\n          printf: ['JWT expired, now %i, exp %i', timestamp - this[CLOCK_TOLERANCE], payload.exp],\n          now: timestamp,\n          tolerance: this[CLOCK_TOLERANCE],\n          exp: payload.exp,\n          jwt,\n        });\n      }\n    }\n\n    if (payload.aud !== undefined) {\n      if (Array.isArray(payload.aud)) {\n        if (payload.aud.length > 1 && !payload.azp) {\n          throw new RPError({\n            message: 'missing required JWT property azp',\n            jwt,\n          });\n        }\n\n        if (!payload.aud.includes(this.client_id)) {\n          throw new RPError({\n            printf: [\n              'aud is missing the client_id, expected %s to be included in %j',\n              this.client_id,\n              payload.aud,\n            ],\n            jwt,\n          });\n        }\n      } else if (payload.aud !== this.client_id) {\n        throw new RPError({\n          printf: ['aud mismatch, expected %s, got: %s', this.client_id, payload.aud],\n          jwt,\n        });\n      }\n    }\n\n    if (payload.azp !== undefined) {\n      let additionalAuthorizedParties = this.#additionalAuthorizedParties;\n\n      if (typeof additionalAuthorizedParties === 'string') {\n        additionalAuthorizedParties = [this.client_id, additionalAuthorizedParties];\n      } else if (Array.isArray(additionalAuthorizedParties)) {\n        additionalAuthorizedParties = [this.client_id, ...additionalAuthorizedParties];\n      } else {\n        additionalAuthorizedParties = [this.client_id];\n      }\n\n      if (!additionalAuthorizedParties.includes(payload.azp)) {\n        throw new RPError({\n          printf: ['azp mismatch, got: %s', payload.azp],\n          jwt,\n        });\n      }\n    }\n\n    let keys;\n\n    if (isSelfIssued) {\n      try {\n        assert(isPlainObject(payload.sub_jwk));\n        const key = await jose.importJWK(payload.sub_jwk, header.alg);\n        assert.equal(key.type, 'public');\n        keys = [{ keyObject: key }];\n      } catch (err) {\n        throw new RPError({\n          message: 'failed to use sub_jwk claim as an asymmetric JSON Web Key',\n          jwt,\n        });\n      }\n      if ((await jose.calculateJwkThumbprint(payload.sub_jwk)) !== payload.sub) {\n        throw new RPError({\n          message: 'failed to match the subject with sub_jwk',\n          jwt,\n        });\n      }\n    } else if (header.alg.startsWith('HS')) {\n      keys = [this.secretForAlg(header.alg)];\n    } else if (header.alg !== 'none') {\n      keys = await queryKeyStore.call(this.issuer, { ...header, use: 'sig' });\n    }\n\n    if (!keys && header.alg === 'none') {\n      return { protected: header, payload };\n    }\n\n    for (const key of keys) {\n      const verified = await jose\n        .compactVerify(jwt, key instanceof Uint8Array ? key : key.keyObject)\n        .catch(() => {});\n      if (verified) {\n        return {\n          payload,\n          protected: verified.protectedHeader,\n          key,\n        };\n      }\n    }\n\n    throw new RPError({\n      message: 'failed to validate JWT signature',\n      jwt,\n    });\n  }\n\n  async refresh(refreshToken, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        throw new TypeError('refresh_token not present in TokenSet');\n      }\n      token = token.refresh_token;\n    }\n\n    const tokenset = await this.grant(\n      {\n        ...exchangeBody,\n        grant_type: 'refresh_token',\n        refresh_token: String(token),\n      },\n      { clientAssertionPayload, DPoP },\n    );\n\n    if (tokenset.id_token) {\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, skipNonceCheck, 'token', skipMaxAgeCheck);\n\n      if (refreshToken instanceof TokenSet && refreshToken.id_token) {\n        const expectedSub = refreshToken.claims().sub;\n        const actualSub = tokenset.claims().sub;\n        if (actualSub !== expectedSub) {\n          throw new RPError({\n            printf: ['sub mismatch, expected %s, got: %s', expectedSub, actualSub],\n            jwt: tokenset.id_token,\n          });\n        }\n      }\n    }\n\n    return tokenset;\n  }\n\n  async requestResource(\n    resourceUrl,\n    accessToken,\n    {\n      method,\n      headers,\n      body,\n      DPoP,\n      tokenType = DPoP\n        ? 'DPoP'\n        : accessToken instanceof TokenSet\n        ? accessToken.token_type\n        : 'Bearer',\n    } = {},\n    retry,\n  ) {\n    if (accessToken instanceof TokenSet) {\n      if (!accessToken.access_token) {\n        throw new TypeError('access_token not present in TokenSet');\n      }\n      accessToken = accessToken.access_token;\n    }\n\n    if (!accessToken) {\n      throw new TypeError('no access token provided');\n    } else if (typeof accessToken !== 'string') {\n      throw new TypeError('invalid access token provided');\n    }\n\n    const requestOpts = {\n      headers: {\n        Authorization: authorizationHeaderValue(accessToken, tokenType),\n        ...headers,\n      },\n      body,\n    };\n\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n\n    const response = await request.call(\n      this,\n      {\n        ...requestOpts,\n        responseType: 'buffer',\n        method,\n        url: resourceUrl,\n      },\n      { accessToken, mTLS, DPoP },\n    );\n\n    const wwwAuthenticate = response.headers['www-authenticate'];\n    if (\n      retry !== retryAttempt &&\n      wwwAuthenticate &&\n      wwwAuthenticate.toLowerCase().startsWith('dpop ') &&\n      parseWwwAuthenticate(wwwAuthenticate).error === 'use_dpop_nonce'\n    ) {\n      return this.requestResource(resourceUrl, accessToken, {\n        method,\n        headers,\n        body,\n        DPoP,\n        tokenType,\n      });\n    }\n\n    return response;\n  }\n\n  async userinfo(accessToken, { method = 'GET', via = 'header', tokenType, params, DPoP } = {}) {\n    assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');\n    const options = {\n      tokenType,\n      method: String(method).toUpperCase(),\n      DPoP,\n    };\n\n    if (options.method !== 'GET' && options.method !== 'POST') {\n      throw new TypeError('#userinfo() method can only be POST or a GET');\n    }\n\n    if (via === 'body' && options.method !== 'POST') {\n      throw new TypeError('can only send body on POST');\n    }\n\n    const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);\n\n    if (jwt) {\n      options.headers = { Accept: 'application/jwt' };\n    } else {\n      options.headers = { Accept: 'application/json' };\n    }\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n\n    let targetUrl;\n    if (mTLS && this.issuer.mtls_endpoint_aliases) {\n      targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n    }\n\n    targetUrl = new url.URL(targetUrl || this.issuer.userinfo_endpoint);\n\n    if (via === 'body') {\n      options.headers.Authorization = undefined;\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.body = new url.URLSearchParams();\n      options.body.append(\n        'access_token',\n        accessToken instanceof TokenSet ? accessToken.access_token : accessToken,\n      );\n    }\n\n    // handle additional parameters, GET via querystring, POST via urlencoded body\n    if (params) {\n      if (options.method === 'GET') {\n        Object.entries(params).forEach(([key, value]) => {\n          targetUrl.searchParams.append(key, value);\n        });\n      } else if (options.body) {\n        // POST && via body\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      } else {\n        // POST && via header\n        options.body = new url.URLSearchParams();\n        options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      }\n    }\n\n    if (options.body) {\n      options.body = options.body.toString();\n    }\n\n    const response = await this.requestResource(targetUrl, accessToken, options);\n\n    let parsed = processResponse(response, { bearer: true });\n\n    if (jwt) {\n      if (!/^application\\/jwt/.test(response.headers['content-type'])) {\n        throw new RPError({\n          message: 'expected application/jwt response from the userinfo_endpoint',\n          response,\n        });\n      }\n\n      const body = response.body.toString();\n      const userinfo = await this.decryptJWTUserinfo(body);\n      if (!this.userinfo_signed_response_alg) {\n        try {\n          parsed = JSON.parse(userinfo);\n          assert(isPlainObject(parsed));\n        } catch (err) {\n          throw new RPError({\n            message: 'failed to parse userinfo JWE payload as JSON',\n            jwt: userinfo,\n          });\n        }\n      } else {\n        ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));\n      }\n    } else {\n      try {\n        parsed = JSON.parse(response.body);\n      } catch (err) {\n        Object.defineProperty(err, 'response', { value: response });\n        throw err;\n      }\n    }\n\n    if (accessToken instanceof TokenSet && accessToken.id_token) {\n      const expectedSub = accessToken.claims().sub;\n      if (parsed.sub !== expectedSub) {\n        throw new RPError({\n          printf: ['userinfo sub mismatch, expected %s, got: %s', expectedSub, parsed.sub],\n          body: parsed,\n          jwt: accessToken.id_token,\n        });\n      }\n    }\n\n    return parsed;\n  }\n\n  encryptionSecret(len) {\n    const hash = len <= 256 ? 'sha256' : len <= 384 ? 'sha384' : len <= 512 ? 'sha512' : false;\n    if (!hash) {\n      throw new Error('unsupported symmetric encryption key derivation');\n    }\n\n    return crypto\n      .createHash(hash)\n      .update(this.client_secret)\n      .digest()\n      .slice(0, len / 8);\n  }\n\n  secretForAlg(alg) {\n    if (!this.client_secret) {\n      throw new TypeError('client_secret is required');\n    }\n\n    if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n      return this.encryptionSecret(parseInt(RegExp.$1, 10));\n    }\n\n    if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n      return this.encryptionSecret(parseInt(RegExp.$2 || RegExp.$1, 10));\n    }\n\n    return new TextEncoder().encode(this.client_secret);\n  }\n\n  async grant(body, { clientAssertionPayload, DPoP } = {}, retry) {\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const response = await authenticatedPost.call(\n      this,\n      'token',\n      {\n        form: body,\n        responseType: 'json',\n      },\n      { clientAssertionPayload, DPoP },\n    );\n    let responseBody;\n    try {\n      responseBody = processResponse(response);\n    } catch (err) {\n      if (retry !== retryAttempt && err instanceof OPError && err.error === 'use_dpop_nonce') {\n        return this.grant(body, { clientAssertionPayload, DPoP }, retryAttempt);\n      }\n      throw err;\n    }\n\n    return new TokenSet(responseBody);\n  }\n\n  async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n    assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n\n    const body = authorizationParams.call(this, {\n      client_id: this.client_id,\n      redirect_uri: null,\n      response_type: null,\n      ...params,\n    });\n\n    const response = await authenticatedPost.call(\n      this,\n      'device_authorization',\n      {\n        responseType: 'json',\n        form: body,\n      },\n      { clientAssertionPayload, endpointAuthMethod: 'token' },\n    );\n    const responseBody = processResponse(response);\n\n    return new DeviceFlowHandle({\n      client: this,\n      exchangeBody,\n      clientAssertionPayload,\n      response: responseBody,\n      maxAge: params.max_age,\n      DPoP,\n    });\n  }\n\n  async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const form = { ...revokeBody, token };\n\n    if (hint) {\n      form.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(\n      this,\n      'revocation',\n      {\n        form,\n      },\n      { clientAssertionPayload },\n    );\n    processResponse(response, { body: false });\n  }\n\n  async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const form = { ...introspectBody, token };\n    if (hint) {\n      form.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(\n      this,\n      'introspection',\n      { form, responseType: 'json' },\n      { clientAssertionPayload },\n    );\n\n    const responseBody = processResponse(response);\n\n    return responseBody;\n  }\n\n  static async register(metadata, options = {}) {\n    const { initialAccessToken, jwks, ...clientOptions } = options;\n\n    assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n\n    if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {\n      const keystore = await getKeystore.call(this, jwks);\n      metadata.jwks = keystore.toJWKS();\n    }\n\n    const response = await request.call(this, {\n      headers: {\n        Accept: 'application/json',\n        ...(initialAccessToken\n          ? {\n              Authorization: authorizationHeaderValue(initialAccessToken),\n            }\n          : undefined),\n      },\n      responseType: 'json',\n      json: metadata,\n      url: this.issuer.registration_endpoint,\n      method: 'POST',\n    });\n    const responseBody = processResponse(response, { statusCode: 201, bearer: true });\n\n    return new this(responseBody, jwks, clientOptions);\n  }\n\n  get metadata() {\n    return clone(Object.fromEntries(this.#metadata.entries()));\n  }\n\n  static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {\n    const response = await request.call(this, {\n      method: 'GET',\n      url: registrationClientUri,\n      responseType: 'json',\n      headers: {\n        Authorization: authorizationHeaderValue(registrationAccessToken),\n        Accept: 'application/json',\n      },\n    });\n    const responseBody = processResponse(response, { bearer: true });\n\n    return new this(responseBody, jwks, clientOptions);\n  }\n\n  async requestObject(\n    requestObject = {},\n    {\n      sign: signingAlgorithm = this.request_object_signing_alg || 'none',\n      encrypt: {\n        alg: eKeyManagement = this.request_object_encryption_alg,\n        enc: eContentEncryption = this.request_object_encryption_enc || 'A128CBC-HS256',\n      } = {},\n    } = {},\n  ) {\n    if (!isPlainObject(requestObject)) {\n      throw new TypeError('requestObject must be a plain object');\n    }\n\n    let signed;\n    let key;\n    const unix = now();\n    const header = { alg: signingAlgorithm, typ: 'oauth-authz-req+jwt' };\n    const payload = JSON.stringify(\n      defaults({}, requestObject, {\n        iss: this.client_id,\n        aud: this.issuer.issuer,\n        client_id: this.client_id,\n        jti: random(),\n        iat: unix,\n        exp: unix + 300,\n        ...(this.fapi() ? { nbf: unix } : undefined),\n      }),\n    );\n    if (signingAlgorithm === 'none') {\n      signed = [base64url.encode(JSON.stringify(header)), base64url.encode(payload), ''].join('.');\n    } else {\n      const symmetric = signingAlgorithm.startsWith('HS');\n      if (symmetric) {\n        key = this.secretForAlg(signingAlgorithm);\n      } else {\n        const keystore = await keystores.get(this);\n\n        if (!keystore) {\n          throw new TypeError(\n            `no keystore present for client, cannot sign using alg ${signingAlgorithm}`,\n          );\n        }\n        key = keystore.get({ alg: signingAlgorithm, use: 'sig' });\n        if (!key) {\n          throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);\n        }\n      }\n\n      signed = await new jose.CompactSign(new TextEncoder().encode(payload))\n        .setProtectedHeader({\n          ...header,\n          kid: symmetric ? undefined : key.jwk.kid,\n        })\n        .sign(symmetric ? key : key.keyObject);\n    }\n\n    if (!eKeyManagement) {\n      return signed;\n    }\n\n    const fields = { alg: eKeyManagement, enc: eContentEncryption, cty: 'oauth-authz-req+jwt' };\n\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      [key] = await queryKeyStore.call(\n        this.issuer,\n        { alg: fields.alg, use: 'enc' },\n        { allowMulti: true },\n      );\n    } else {\n      key = this.secretForAlg(fields.alg === 'dir' ? fields.enc : fields.alg);\n    }\n\n    return new jose.CompactEncrypt(new TextEncoder().encode(signed))\n      .setProtectedHeader({\n        ...fields,\n        kid: key instanceof Uint8Array ? undefined : key.jwk.kid,\n      })\n      .encrypt(key instanceof Uint8Array ? key : key.keyObject);\n  }\n\n  async pushedAuthorizationRequest(params = {}, { clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'pushed_authorization_request_endpoint');\n\n    const body = {\n      ...('request' in params ? params : authorizationParams.call(this, params)),\n      client_id: this.client_id,\n    };\n\n    const response = await authenticatedPost.call(\n      this,\n      'pushed_authorization_request',\n      {\n        responseType: 'json',\n        form: body,\n      },\n      { clientAssertionPayload, endpointAuthMethod: 'token' },\n    );\n    const responseBody = processResponse(response, { statusCode: 201 });\n\n    if (!('expires_in' in responseBody)) {\n      throw new RPError({\n        message: 'expected expires_in in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n    if (typeof responseBody.expires_in !== 'number') {\n      throw new RPError({\n        message: 'invalid expires_in value in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n    if (!('request_uri' in responseBody)) {\n      throw new RPError({\n        message: 'expected request_uri in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n    if (typeof responseBody.request_uri !== 'string') {\n      throw new RPError({\n        message: 'invalid request_uri value in Pushed Authorization Successful Response',\n        response,\n      });\n    }\n\n    return responseBody;\n  }\n\n  get issuer() {\n    return this.#issuer;\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true,\n    })}`;\n  }\n\n  fapi() {\n    return this.constructor.name === 'FAPI1Client';\n  }\n\n  async validateJARM(response) {\n    const expectedAlg = this.authorization_signed_response_alg;\n    const { payload } = await this.validateJWT(response, expectedAlg, ['iss', 'exp', 'aud']);\n    return pickCb(payload);\n  }\n}\n\nconst RSPS = /^(?:RS|PS)(?:256|384|512)$/;\nfunction determineRsaAlgorithm(privateKey, privateKeyInput, valuesSupported) {\n  if (\n    typeof privateKeyInput === 'object' &&\n    typeof privateKeyInput.key === 'object' &&\n    privateKeyInput.key.alg\n  ) {\n    return privateKeyInput.key.alg;\n  }\n\n  if (Array.isArray(valuesSupported)) {\n    let candidates = valuesSupported.filter(RegExp.prototype.test.bind(RSPS));\n    if (privateKey.asymmetricKeyType === 'rsa-pss') {\n      candidates = candidates.filter((value) => value.startsWith('PS'));\n    }\n    return ['PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS384'].find((preferred) =>\n      candidates.includes(preferred),\n    );\n  }\n\n  return 'PS256';\n}\n\nconst p256 = Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);\nconst p384 = Buffer.from([43, 129, 4, 0, 34]);\nconst p521 = Buffer.from([43, 129, 4, 0, 35]);\nconst secp256k1 = Buffer.from([43, 129, 4, 0, 10]);\n\nfunction determineEcAlgorithm(privateKey, privateKeyInput) {\n  // If input was a JWK\n  switch (\n    typeof privateKeyInput === 'object' &&\n    typeof privateKeyInput.key === 'object' &&\n    privateKeyInput.key.crv\n  ) {\n    case 'P-256':\n      return 'ES256';\n    case 'secp256k1':\n      return 'ES256K';\n    case 'P-384':\n      return 'ES384';\n    case 'P-512':\n      return 'ES512';\n    default:\n      break;\n  }\n\n  const buf = privateKey.export({ format: 'der', type: 'pkcs8' });\n  const i = buf[1] < 128 ? 17 : 18;\n  const len = buf[i];\n  const curveOid = buf.slice(i + 1, i + 1 + len);\n  if (curveOid.equals(p256)) {\n    return 'ES256';\n  }\n\n  if (curveOid.equals(p384)) {\n    return 'ES384';\n  }\n  if (curveOid.equals(p521)) {\n    return 'ES512';\n  }\n\n  if (curveOid.equals(secp256k1)) {\n    return 'ES256K';\n  }\n\n  throw new TypeError('unsupported DPoP private key curve');\n}\n\nconst jwkCache = new WeakMap();\nasync function getJwk(privateKey, privateKeyInput) {\n  if (\n    typeof privateKeyInput === 'object' &&\n    typeof privateKeyInput.key === 'object' &&\n    privateKeyInput.key.crv\n  ) {\n    return pick(privateKeyInput.key, 'kty', 'crv', 'x', 'y', 'e', 'n');\n  }\n\n  if (jwkCache.has(privateKeyInput)) {\n    return jwkCache.get(privateKeyInput);\n  }\n\n  const jwk = pick(await jose.exportJWK(privateKey), 'kty', 'crv', 'x', 'y', 'e', 'n');\n\n  if (isKeyObject(privateKeyInput)) {\n    jwkCache.set(privateKeyInput, jwk);\n  }\n\n  return jwk;\n}\n\n/**\n * @name dpopProof\n * @api private\n */\nasync function dpopProof(payload, privateKeyInput, accessToken) {\n  if (!isPlainObject(payload)) {\n    throw new TypeError('payload must be a plain object');\n  }\n\n  let privateKey;\n  if (isKeyObject(privateKeyInput)) {\n    privateKey = privateKeyInput;\n  } else {\n    privateKey = crypto.createPrivateKey(privateKeyInput);\n  }\n\n  if (privateKey.type !== 'private') {\n    throw new TypeError('\"DPoP\" option must be a private key');\n  }\n  let alg;\n  switch (privateKey.asymmetricKeyType) {\n    case 'ed25519':\n    case 'ed448':\n      alg = 'EdDSA';\n      break;\n    case 'ec':\n      alg = determineEcAlgorithm(privateKey, privateKeyInput);\n      break;\n    case 'rsa':\n    case rsaPssParams && 'rsa-pss':\n      alg = determineRsaAlgorithm(\n        privateKey,\n        privateKeyInput,\n        this.issuer.dpop_signing_alg_values_supported,\n      );\n      break;\n    default:\n      throw new TypeError('unsupported DPoP private key asymmetric key type');\n  }\n\n  if (!alg) {\n    throw new TypeError('could not determine DPoP JWS Algorithm');\n  }\n\n  return new jose.SignJWT({\n    ath: accessToken\n      ? base64url.encode(crypto.createHash('sha256').update(accessToken).digest())\n      : undefined,\n    ...payload,\n  })\n    .setProtectedHeader({\n      alg,\n      typ: 'dpop+jwt',\n      jwk: await getJwk(privateKey, privateKeyInput),\n    })\n    .setIssuedAt()\n    .setJti(random())\n    .sign(privateKey);\n}\n\nObject.defineProperty(BaseClient.prototype, 'dpopProof', {\n  enumerable: true,\n  configurable: true,\n  value(...args) {\n    process.emitWarning(\n      'The DPoP APIs implements an IETF draft (https://www.ietf.org/archive/id/draft-ietf-oauth-dpop-04.html). Breaking draft implementations are included as minor versions of the openid-client library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.',\n      'DraftWarning',\n    );\n    Object.defineProperty(BaseClient.prototype, 'dpopProof', {\n      enumerable: true,\n      configurable: true,\n      value: dpopProof,\n    });\n    return this.dpopProof(...args);\n  },\n});\n\nmodule.exports = (issuer, aadIssValidation = false) =>\n  class Client extends BaseClient {\n    constructor(...args) {\n      super(issuer, aadIssValidation, ...args);\n    }\n\n    static get issuer() {\n      return issuer;\n    }\n  };\nmodule.exports.BaseClient = BaseClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}