{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\yuleg\\\\Dev\\\\Ringca\\\\ORIN33\\\\ringcard\\\\ringcard_frontend\\\\src\\\\pages\\\\login\\\\Oauth.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { TwitterApi } from 'twitter-api-v2';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Oauth = () => {\n  _s();\n  const CONSUMER_KEY = process.env.REACT_APP_CONSUMER_KEY;\n  const CONSUMER_SECRET = process.env.REACT_APP_CONSUMER_SECRET;\n  const CLIENT_ID = process.env.REACT_APP_CLIENT_ID;\n  const CLIENT_SECRET = process.env.REACT_APP_CLIENT_SECRET;\n  const CALLBACK_URL = process.env.REACT_APP_CALLBACK_URL;\n  const BEARER_TOKEN = process.env.REACT_APP_BEARER_TOKEN;\n  const navigate = useNavigate();\n\n  // var global = global || window;\n  global.Buffer = global.Buffer || require(\"buffer\").Buffer;\n\n  // 일단 oauth1.0a로 해보자.\n  // const client = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\n\n  // useEffect(() => {\n  //   const oauthTest = async () => {\n  //     if(CONSUMER_KEY && CONSUMER_SECRET){\n  //     const clientA = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\n\n  //     console.log(clientA);\n\n  //     const authLink = await clientA.generateAuthLink(CALLBACK_URL);\n  //     console.log(authLink.url);\n  //   }\n  // };\n  // \toauthTest();\n  // }, []);\n\n  // 애플리케이션 전용 인증 흐름\n  useEffect(() => {\n    const oauthTest = async () => {\n      if (CONSUMER_KEY && CONSUMER_SECRET && BEARER_TOKEN) {\n        const client = new TwitterApi(BEARER_TOKEN);\n        console.log(client);\n        const consumerClient = new TwitterApi({\n          appKey: CONSUMER_KEY,\n          appSecret: CONSUMER_SECRET\n        });\n        // Obtain app-only client\n        const clientA = await consumerClient.appLogin();\n        console.log(clientA);\n\n        // const authLink = await clientA.generateAuthLink(CALLBACK_URL);\n        // console.log(authLink.url);\n      }\n    };\n\n    oauthTest();\n  }, []);\n\n  // OAuth 1.0a (User context)\n  const userClient = new TwitterApi({\n    // appKey: 'consumerAppKey',\n    appKey: 'S0FVySANFNnlISMw5D1vSE8P0',\n    // appSecret: 'consumerAppSecret',\n    appSecret: 'KCu23eNrVftMqQeefWJTIei5Klju341e78BypImTVfw338Mm0X',\n    // Following access tokens are not required if you are\n    // at part 1 of user-auth process (ask for a request token)\n    // or if you want a app-only client (see below)\n    // accessToken: 'accessOAuthToken',\n    accessToken: '1516353113430851586-Qhjz3YpRRL1yFqSa5PYcyjf5gmJhU1',\n    // accessSecret: 'accessOAuthSecret',\n    accessSecret: 'accdPvdajDmTYtMybqbj9mOMnTIvbE9SnOuJY8h9uRQjRxlnessOAuthSecret'\n  });\n  async function Oauth1a() {\n    if (CONSUMER_KEY && CONSUMER_SECRET) {\n      const clientA = new TwitterApi({\n        appKey: CONSUMER_KEY,\n        appSecret: CONSUMER_SECRET\n      });\n      console.log(clientA);\n      const authLink = await clientA.generateAuthLink(CALLBACK_URL, {\n        linkMode: 'authorize'\n      });\n\n      // Obtain the persistent tokens\n      // Create a client from temporary tokens\n\n      //   const client = new TwitterApi({\n      //   appKey: CONSUMER_KEY,\n      //   appSecret: CONSUMER_SECRET,\n      //   accessToken: oauth_token, // oauth token from previous step (link generation)\n      //   accessSecret: oauth_token_secret, // oauth token secret from previous step (link generation)\n      // });\n\n      // By default, oauth/authenticate are used for auth links, you can change with linkMode\n      // property in second parameter to 'authorize' to use oauth/authorize\n      // if(client){\n      //   const authLink = await client.generateAuthLink(CALLBACK_URL, { linkMode: 'authorize' });\n      // }\n\n      // Use URL generated\n      const a = authLink.url;\n      const oauth_token = authLink.oauth_token;\n      const oauth_token_secret = authLink.oauth_token_secret;\n      console.log(oauth_token);\n      console.log(oauth_token_secret);\n      // console.log(a);\n\n      // Give the PIN to client.login()\n      // const { client: loggedClient, accessToken, accessSecret } = await client.login(GIVEN_USER_PIN);\n      // loggedClient is an authenticated client in behalf of some user\n      // Store accessToken & accessSecret somewhere\n    }\n  }\n\n  function ButtonToUserInfoEdit() {\n    function handleClick(e) {\n      Oauth1a();\n    }\n    return /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"user-btn userInfo-btn\",\n      onClick: handleClick,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"user-btn-text\",\n        children: \"\\uD504\\uB85C\\uD544 \\uBCC0\\uACBD\\uD558\\uAE30\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 120,\n        columnNumber: 5\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 4\n    }, this);\n  }\n\n  //   // OAuth2 (app-only or user context)\n  //   // Create a client with an already known bearer token\n  //   const appOnlyClient = new TwitterApi('bearerToken');\n  //   // OR - you can also create a app-only client from your consumer keys -\n  //   const appOnlyClientFromConsumer = await userClient.appLogin();\n\n  //   // Oauth2\n  // \t// if로 undefined 처리)\n  // \tif (CLIENT_ID && CLIENT_SECRET && CALLBACK_URL){\n  // \t\tconst client = new TwitterApi({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET });\n\n  // \t\t// Don't forget to specify 'offline.access' in scope list if you want to refresh your token later\n  // \t\tconst { url, codeVerifier, state } = client.generateOAuth2AuthLink(CALLBACK_URL, { scope: ['tweet.read', 'users.read', 'offline.access'] });\n\n  // \t\t// Redirect your user to {url}, store {state} and {codeVerifier} into a DB/Redis/memory after user redirection\n\n  //     // const a = url;\n  //     // console.log(a);\n  // \t\t// client.generateAuthLink();\n  // \t\tnavigate(url);\n  //     // console.log(url);\n  // \t\t// console.log(url);\n\n  //   app.get('/callback', (req:any, res:any) => {\n  //   // Extract state and code from query string\n  //   const { state, code } = req.query;\n  //   // Get the saved codeVerifier from session\n  //   const { codeVerifier, state: sessionState } = req.session;\n\n  //   if (!codeVerifier || !state || !sessionState || !code) {\n  //     return res.status(400).send('You denied the app or your session expired!');\n  //   }\n  //   if (state !== sessionState) {\n  //     return res.status(400).send('Stored tokens didnt match!');\n  //   }\n\n  //   // Obtain access token\n  //   const client = new TwitterApi({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET });\n\n  //   client.loginWithOAuth2({ code, codeVerifier, redirectUri: CALLBACK_URL })\n  //     .then(async ({ client: loggedClient, accessToken, refreshToken, expiresIn }) => {\n  //       // {loggedClient} is an authenticated client in behalf of some user\n  //       // Store {accessToken} somewhere, it will be valid until {expiresIn} is hit.\n  //       // If you want to refresh your token later, store {refreshToken} (it is present if 'offline.access' has been given as scope)\n\n  //       // Example request\n  //       const { data: userObject } = await loggedClient.v2.me();\n  //     })\n  //     .catch(() => res.status(403).send('Invalid verifier or access tokens!'));\n  // });\n  // }\n\n  return /*#__PURE__*/_jsxDEV(ButtonToUserInfoEdit, {}, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 179,\n    columnNumber: 10\n  }, this);\n};\n_s(Oauth, \"0pNeyzXk/ByIxyERsdaIrG6js9s=\", false, function () {\n  return [useNavigate];\n});\n_c = Oauth;\nexport default Oauth;\nvar _c;\n$RefreshReg$(_c, \"Oauth\");","map":{"version":3,"names":["React","useEffect","useNavigate","TwitterApi","Oauth","CONSUMER_KEY","process","env","REACT_APP_CONSUMER_KEY","CONSUMER_SECRET","REACT_APP_CONSUMER_SECRET","CLIENT_ID","REACT_APP_CLIENT_ID","CLIENT_SECRET","REACT_APP_CLIENT_SECRET","CALLBACK_URL","REACT_APP_CALLBACK_URL","BEARER_TOKEN","REACT_APP_BEARER_TOKEN","navigate","global","Buffer","require","oauthTest","client","console","log","consumerClient","appKey","appSecret","clientA","appLogin","userClient","accessToken","accessSecret","Oauth1a","authLink","generateAuthLink","linkMode","a","url","oauth_token","oauth_token_secret","ButtonToUserInfoEdit","handleClick","e"],"sources":["C:/Users/yuleg/Dev/Ringca/ORIN33/ringcard/ringcard_frontend/src/pages/login/Oauth.tsx"],"sourcesContent":["import React, { useEffect } from \"react\";\r\nimport { useNavigate } from \"react-router-dom\";\r\nimport { TwitterApi } from 'twitter-api-v2';\r\nimport { Buffer } from \"buffer\";\r\n\r\nconst Oauth= ()=>{\r\n\r\n  const CONSUMER_KEY=process.env.REACT_APP_CONSUMER_KEY;\r\n  const CONSUMER_SECRET=process.env.REACT_APP_CONSUMER_SECRET;\r\n  const CLIENT_ID=process.env.REACT_APP_CLIENT_ID;\r\n\tconst CLIENT_SECRET=process.env.REACT_APP_CLIENT_SECRET;\r\n\tconst CALLBACK_URL=process.env.REACT_APP_CALLBACK_URL;\r\n\tconst BEARER_TOKEN=process.env.REACT_APP_BEARER_TOKEN;\r\n\tconst navigate = useNavigate();\r\n\r\n  // var global = global || window;\r\n    global.Buffer = global.Buffer || require(\"buffer\").Buffer;  \r\n\r\n  // 일단 oauth1.0a로 해보자.\r\n  // const client = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\r\n\r\n  // useEffect(() => {\r\n  //   const oauthTest = async () => {\r\n  //     if(CONSUMER_KEY && CONSUMER_SECRET){\r\n  //     const clientA = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\r\n\r\n  //     console.log(clientA);\r\n\r\n  //     const authLink = await clientA.generateAuthLink(CALLBACK_URL);\r\n  //     console.log(authLink.url);\r\n  //   }\r\n  // };\r\n\t// \toauthTest();\r\n\t// }, []);\r\n\r\n  // 애플리케이션 전용 인증 흐름\r\n  useEffect(() => {\r\n    const oauthTest = async () => {\r\n      if(CONSUMER_KEY && CONSUMER_SECRET && BEARER_TOKEN){\r\n      const client = new TwitterApi(BEARER_TOKEN);\r\nconsole.log(client);\r\n      const consumerClient = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\r\n      // Obtain app-only client\r\n      const clientA = await consumerClient.appLogin();\r\n\r\n      console.log(clientA);\r\n\r\n      // const authLink = await clientA.generateAuthLink(CALLBACK_URL);\r\n      // console.log(authLink.url);\r\n    }\r\n  };\r\n\t\toauthTest();\r\n\t}, []);\r\n\r\n  // OAuth 1.0a (User context)\r\n  const userClient = new TwitterApi({\r\n    // appKey: 'consumerAppKey',\r\n    appKey: 'S0FVySANFNnlISMw5D1vSE8P0',\r\n    // appSecret: 'consumerAppSecret',\r\n    appSecret: 'KCu23eNrVftMqQeefWJTIei5Klju341e78BypImTVfw338Mm0X',\r\n    // Following access tokens are not required if you are\r\n    // at part 1 of user-auth process (ask for a request token)\r\n    // or if you want a app-only client (see below)\r\n    // accessToken: 'accessOAuthToken',\r\n    accessToken: '1516353113430851586-Qhjz3YpRRL1yFqSa5PYcyjf5gmJhU1',\r\n    // accessSecret: 'accessOAuthSecret',\r\n    accessSecret: 'accdPvdajDmTYtMybqbj9mOMnTIvbE9SnOuJY8h9uRQjRxlnessOAuthSecret',\r\n  });\r\n  async function Oauth1a(){\r\n    if(CONSUMER_KEY && CONSUMER_SECRET){\r\n      const clientA = new TwitterApi({ appKey: CONSUMER_KEY, appSecret: CONSUMER_SECRET });\r\n\r\n      console.log(clientA);\r\n\r\n      const authLink = await clientA.generateAuthLink(CALLBACK_URL, { linkMode: 'authorize' });\r\n\r\n\r\n       // Obtain the persistent tokens\r\n  // Create a client from temporary tokens\r\n\r\n\r\n\r\n  //   const client = new TwitterApi({\r\n  //   appKey: CONSUMER_KEY,\r\n  //   appSecret: CONSUMER_SECRET,\r\n  //   accessToken: oauth_token, // oauth token from previous step (link generation)\r\n  //   accessSecret: oauth_token_secret, // oauth token secret from previous step (link generation)\r\n  // });\r\n\r\n    // By default, oauth/authenticate are used for auth links, you can change with linkMode\r\n    // property in second parameter to 'authorize' to use oauth/authorize\r\n    // if(client){\r\n    //   const authLink = await client.generateAuthLink(CALLBACK_URL, { linkMode: 'authorize' });\r\n    // }\r\n    \r\n\r\n    // Use URL generated\r\n    const a = authLink.url;\r\n    const oauth_token = authLink.oauth_token;\r\n    const oauth_token_secret = authLink.oauth_token_secret;\r\n    console.log(oauth_token);\r\n    console.log(oauth_token_secret);\r\n    // console.log(a);\r\n\r\n   \r\n\r\n// Give the PIN to client.login()\r\n// const { client: loggedClient, accessToken, accessSecret } = await client.login(GIVEN_USER_PIN);\r\n// loggedClient is an authenticated client in behalf of some user\r\n// Store accessToken & accessSecret somewhere\r\n    }\r\n  }\r\n\r\n  function ButtonToUserInfoEdit() {\r\n\t\tfunction handleClick(e: any) {\r\n      Oauth1a();\r\n    }\r\n\t\treturn (\r\n\t\t\t<button className=\"user-btn userInfo-btn\" onClick={handleClick}>\r\n\t\t\t\t<div className=\"user-btn-text\">프로필 변경하기</div>\r\n\t\t\t</button>\r\n\t\t);\r\n\t}\r\n\r\n\r\n\r\n//   // OAuth2 (app-only or user context)\r\n//   // Create a client with an already known bearer token\r\n//   const appOnlyClient = new TwitterApi('bearerToken');\r\n//   // OR - you can also create a app-only client from your consumer keys -\r\n//   const appOnlyClientFromConsumer = await userClient.appLogin();\r\n\r\n//   // Oauth2\r\n// \t// if로 undefined 처리)\r\n// \tif (CLIENT_ID && CLIENT_SECRET && CALLBACK_URL){\r\n// \t\tconst client = new TwitterApi({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET });\r\n\r\n// \t\t// Don't forget to specify 'offline.access' in scope list if you want to refresh your token later\r\n// \t\tconst { url, codeVerifier, state } = client.generateOAuth2AuthLink(CALLBACK_URL, { scope: ['tweet.read', 'users.read', 'offline.access'] });\r\n\r\n// \t\t// Redirect your user to {url}, store {state} and {codeVerifier} into a DB/Redis/memory after user redirection\r\n    \r\n//     // const a = url;\r\n//     // console.log(a);\r\n// \t\t// client.generateAuthLink();\r\n// \t\tnavigate(url);\r\n//     // console.log(url);\r\n// \t\t// console.log(url);\r\n\r\n//   app.get('/callback', (req:any, res:any) => {\r\n//   // Extract state and code from query string\r\n//   const { state, code } = req.query;\r\n//   // Get the saved codeVerifier from session\r\n//   const { codeVerifier, state: sessionState } = req.session;\r\n\r\n//   if (!codeVerifier || !state || !sessionState || !code) {\r\n//     return res.status(400).send('You denied the app or your session expired!');\r\n//   }\r\n//   if (state !== sessionState) {\r\n//     return res.status(400).send('Stored tokens didnt match!');\r\n//   }\r\n\r\n//   // Obtain access token\r\n//   const client = new TwitterApi({ clientId: CLIENT_ID, clientSecret: CLIENT_SECRET });\r\n\r\n//   client.loginWithOAuth2({ code, codeVerifier, redirectUri: CALLBACK_URL })\r\n//     .then(async ({ client: loggedClient, accessToken, refreshToken, expiresIn }) => {\r\n//       // {loggedClient} is an authenticated client in behalf of some user\r\n//       // Store {accessToken} somewhere, it will be valid until {expiresIn} is hit.\r\n//       // If you want to refresh your token later, store {refreshToken} (it is present if 'offline.access' has been given as scope)\r\n\r\n//       // Example request\r\n//       const { data: userObject } = await loggedClient.v2.me();\r\n//     })\r\n//     .catch(() => res.status(403).send('Invalid verifier or access tokens!'));\r\n// });\r\n\t// }\r\n\r\n  return(<ButtonToUserInfoEdit />);\r\n\r\n}\r\n\r\nexport default Oauth;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}